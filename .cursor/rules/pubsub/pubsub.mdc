---
alwaysApply: false
description: Guidelines for working with GCP Pub/Sub using the Go v2 client library
---

# GCP Pub/Sub v2 Client Guidelines

This project uses `cloud.google.com/go/pubsub/v2` for all Pub/Sub operations. Follow these patterns and best practices.

## Client Creation

> **Note:** For authentication methods (ADC, Service Account, OAuth), see `auth.mdc`.

### Basic Client Creation

```go
import "cloud.google.com/go/pubsub/v2"

ctx := context.Background()
client, err := pubsub.NewClient(ctx, "my-project-id")
if err != nil {
    return err
}
defer client.Close()
```

**Emulator Support:**

When using the emulator, use `option.WithoutAuthentication()`:

```go
import (
    "cloud.google.com/go/pubsub/v2"
    "google.golang.org/api/option"
)

opts := []option.ClientOption{}
if os.Getenv("PUBSUB_EMULATOR_HOST") != "" {
    opts = append(opts, option.WithoutAuthentication())
}
client, err := pubsub.NewClient(ctx, projectID, opts...)
```

## Admin Operations

### Topics

Use `client.TopicAdminClient` for topic management operations.

**List Topics:**

```go
import (
    "cloud.google.com/go/pubsub/v2/apiv1/pubsubpb"
    "google.golang.org/api/iterator"
)

req := &pubsubpb.ListTopicsRequest{
    Project: "projects/" + projectID,
}
it := client.TopicAdminClient.ListTopics(ctx, req)

for {
    topic, err := it.Next()
    if err == iterator.Done {
        break
    }
    if err != nil {
        return err
    }
    // Process topic
}
```

**Get Topic:**

```go
topicName := "projects/" + projectID + "/topics/" + topicID
req := &pubsubpb.GetTopicRequest{
    Topic: topicName,
}
topic, err := client.TopicAdminClient.GetTopic(ctx, req)
```

**Create Topic:**

Always normalize the topic ID first (extract short name if full path provided). See implementation in `internal/pubsub/admin/topics.go`:

```go 84:119:internal/pubsub/admin/topics.go
// CreateTopicAdmin creates a new topic with optional message retention duration
func CreateTopicAdmin(ctx context.Context, client *pubsub.Client, projectID, topicID string, messageRetentionDuration string) error {
	// Normalize topic ID (extract short name if full path provided)
	shortTopicID := topicID
	if strings.HasPrefix(topicID, "projects/") {
		// Extract topic ID from full path: projects/{project}/topics/{topic-id}
		parts := strings.Split(topicID, "/")
		if len(parts) >= 4 && parts[0] == "projects" && parts[2] == "topics" {
			shortTopicID = parts[3]
		}
	}

	// Build full resource name
	topicName := "projects/" + projectID + "/topics/" + shortTopicID

	// Create topic using Topic object directly (v2 API pattern)
	req := &pubsubpb.Topic{
		Name: topicName,
	}

	// Set message retention duration if provided
	if messageRetentionDuration != "" {
		duration, err := time.ParseDuration(messageRetentionDuration)
		if err != nil {
			return fmt.Errorf("invalid message retention duration format: %w", err)
		}
		req.MessageRetentionDuration = durationpb.New(duration)
	}

	_, err := client.TopicAdminClient.CreateTopic(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to create topic %s: %w. Ensure you have 'pubsub.topics.create' permission", topicName, err)
	}

	return nil
}
```

**Delete Topic:**

See implementation in `internal/pubsub/admin/topics.go`:

```go 121:139:internal/pubsub/admin/topics.go
// DeleteTopicAdmin deletes a topic
func DeleteTopicAdmin(ctx context.Context, client *pubsub.Client, projectID, topicID string) error {
	// Normalize topic ID
	topicName := topicID
	if !strings.HasPrefix(topicID, "projects/") {
		topicName = "projects/" + projectID + "/topics/" + topicID
	}

	deleteReq := &pubsubpb.DeleteTopicRequest{
		Topic: topicName,
	}

	err := client.TopicAdminClient.DeleteTopic(ctx, deleteReq)
	if err != nil {
		return fmt.Errorf("failed to delete topic: %w", err)
	}

	return nil
}
```

### Subscriptions

Use `client.SubscriptionAdminClient` for subscription management operations.

**List Subscriptions:**

```go
req := &pubsubpb.ListSubscriptionsRequest{
    Project: "projects/" + projectID,
}
it := client.SubscriptionAdminClient.ListSubscriptions(ctx, req)

for {
    sub, err := it.Next()
    if err == iterator.Done {
        break
    }
    if err != nil {
        return err
    }
    // Process subscription
}
```

**Get Subscription:**

```go
subName := "projects/" + projectID + "/subscriptions/" + subID
req := &pubsubpb.GetSubscriptionRequest{
    Subscription: subName,
}
sub, err := client.SubscriptionAdminClient.GetSubscription(ctx, req)
```

**Create Subscription:**

Always normalize both subscription ID and topic ID first (extract short names if full paths provided). See implementation in `internal/pubsub/admin/subscriptions.go`:

```go 133:185:internal/pubsub/admin/subscriptions.go
// CreateSubscriptionAdmin creates a new subscription for a topic
func CreateSubscriptionAdmin(ctx context.Context, client *pubsub.Client, projectID, topicID, subID string, ttl time.Duration) error {
	// Normalize subscription ID (extract short name if full path provided)
	shortSubID := subID
	if strings.HasPrefix(subID, "projects/") {
		// Extract subscription ID from full path: projects/{project}/subscriptions/{sub-id}
		parts := strings.Split(subID, "/")
		if len(parts) >= 4 && parts[0] == "projects" && parts[2] == "subscriptions" {
			shortSubID = parts[3]
		}
	}

	// Normalize topic ID (extract short name if full path provided)
	shortTopicID := topicID
	if strings.HasPrefix(topicID, "projects/") {
		// Extract topic ID from full path: projects/{project}/topics/{topic-id}
		parts := strings.Split(topicID, "/")
		if len(parts) >= 4 && parts[0] == "projects" && parts[2] == "topics" {
			shortTopicID = parts[3]
		}
	}

	// Build full resource names
	subName := "projects/" + projectID + "/subscriptions/" + shortSubID
	topicName := "projects/" + projectID + "/topics/" + shortTopicID

	// Verify topic exists before creating subscription
	topicReq := &pubsubpb.GetTopicRequest{
		Topic: topicName,
	}
	_, err := client.TopicAdminClient.GetTopic(ctx, topicReq)
	if err != nil {
		return fmt.Errorf("topic %s does not exist or you don't have permission to access it: %w", topicName, err)
	}

	// Create subscription using Subscription object directly (v2 API pattern)
	req := &pubsubpb.Subscription{
		Name:  subName,
		Topic: topicName,
		// Set expiration policy to automatically delete the subscription after it's been idle for ttl
		ExpirationPolicy: &pubsubpb.ExpirationPolicy{
			Ttl: durationpb.New(ttl),
		},
	}

	_, err = client.SubscriptionAdminClient.CreateSubscription(ctx, req)
	if err != nil {
		// Provide more helpful error message
		return fmt.Errorf("failed to create subscription %s for topic %s: %w. Ensure you have 'pubsub.subscriptions.create' permission", subName, topicName, err)
	}

	return nil
}
```

**Update Subscription:**

See implementation in `internal/pubsub/admin/subscriptions.go`:

```go 216:309:internal/pubsub/admin/subscriptions.go
// UpdateSubscriptionAdmin updates a subscription's configuration
func UpdateSubscriptionAdmin(ctx context.Context, client *pubsub.Client, projectID, subID string, params SubscriptionUpdateParams) error {
	// Normalize subscription ID
	subName := subID
	if !strings.HasPrefix(subID, "projects/") {
		subName = "projects/" + projectID + "/subscriptions/" + subID
	}

	// Get current subscription to merge updates
	getReq := &pubsubpb.GetSubscriptionRequest{
		Subscription: subName,
	}
	currentSub, err := client.SubscriptionAdminClient.GetSubscription(ctx, getReq)
	if err != nil {
		return fmt.Errorf("failed to get subscription: %w", err)
	}

	// Create updated subscription (copy current)
	updatedSub := proto.Clone(currentSub).(*pubsubpb.Subscription)
	var updateMask []string

	// Update ack deadline if provided
	if params.AckDeadline != nil {
		updatedSub.AckDeadlineSeconds = int32(*params.AckDeadline)
		updateMask = append(updateMask, "ack_deadline_seconds")
	}

	// Update retention duration if provided
	if params.RetentionDuration != nil {
		duration, err := time.ParseDuration(*params.RetentionDuration)
		if err != nil {
			return fmt.Errorf("invalid retention duration format: %w", err)
		}
		updatedSub.MessageRetentionDuration = durationpb.New(duration)
		updateMask = append(updateMask, "message_retention_duration")
	}

	// Update filter if provided
	if params.Filter != nil {
		updatedSub.Filter = *params.Filter
		updateMask = append(updateMask, "filter")
	}

	// Update dead letter policy if provided
	if params.DeadLetterPolicy != nil {
		if updatedSub.DeadLetterPolicy == nil {
			updatedSub.DeadLetterPolicy = &pubsubpb.DeadLetterPolicy{}
		}
		if params.DeadLetterPolicy.DeadLetterTopic != "" {
			updatedSub.DeadLetterPolicy.DeadLetterTopic = params.DeadLetterPolicy.DeadLetterTopic
		}
		if params.DeadLetterPolicy.MaxDeliveryAttempts > 0 {
			updatedSub.DeadLetterPolicy.MaxDeliveryAttempts = int32(params.DeadLetterPolicy.MaxDeliveryAttempts)
		}
		updateMask = append(updateMask, "dead_letter_policy")
	}

	// Update push config if subscription type or endpoint changed
	if params.SubscriptionType != nil || params.PushEndpoint != nil {
		if *params.SubscriptionType == "push" {
			if updatedSub.PushConfig == nil {
				updatedSub.PushConfig = &pubsubpb.PushConfig{}
			}
			if params.PushEndpoint != nil {
				updatedSub.PushConfig.PushEndpoint = *params.PushEndpoint
			}
			updateMask = append(updateMask, "push_config")
		} else if *params.SubscriptionType == "pull" {
			// Clear push config for pull subscriptions
			updatedSub.PushConfig = nil
			updateMask = append(updateMask, "push_config")
		}
	}

	// If no fields to update, return early
	if len(updateMask) == 0 {
		return fmt.Errorf("no fields specified for update")
	}

	// Create update request with field mask
	updateReq := &pubsubpb.UpdateSubscriptionRequest{
		Subscription: updatedSub,
		UpdateMask: &fieldmaskpb.FieldMask{
			Paths: updateMask,
		},
	}

	_, err = client.SubscriptionAdminClient.UpdateSubscription(ctx, updateReq)
	if err != nil {
		return fmt.Errorf("failed to update subscription: %w", err)
	}

	return nil
}
```

**Delete Subscription:**

See implementation in `internal/pubsub/admin/subscriptions.go`:

```go 187:204:internal/pubsub/admin/subscriptions.go
// DeleteSubscriptionAdmin deletes a subscription
func DeleteSubscriptionAdmin(ctx context.Context, client *pubsub.Client, projectID, subID string) error {
	subName := subID
	if !strings.HasPrefix(subID, "projects/") {
		subName = "projects/" + projectID + "/subscriptions/" + subID
	}

	deleteReq := &pubsubpb.DeleteSubscriptionRequest{
		Subscription: subName,
	}

	err := client.SubscriptionAdminClient.DeleteSubscription(ctx, deleteReq)
	if err != nil {
		return fmt.Errorf("failed to delete subscription: %w", err)
	}

	return nil
}
```

## Publishing Messages

> **Note:** For saving and reusing message patterns, see the Message Templates system in `message-publishing.mdc`.

### Basic Publishing

```go
// Get publisher (can use full name or short name)
publisher := client.Publisher("projects/my-project/topics/my-topic")
// OR
publisher := client.Publisher("my-topic") // Short form works too

// Publish a message
msg := &pubsub.Message{
    Data: []byte("message payload"),
    Attributes: map[string]string{
        "key": "value",
    },
}
result := publisher.Publish(ctx, msg)

// Wait for publish to complete (optional)
id, err := result.Get(ctx)
if err != nil {
    return err
}
```

### Publishing Best Practices

- `Publisher.Publish()` queues messages and returns immediately
- Messages are batched automatically for efficiency
- Always call `publisher.Stop()` when done to clean up goroutines
- Use `PublishResult.Get(ctx)` to wait for confirmation if needed

```go
defer publisher.Stop()

// Publish multiple messages
for _, data := range messages {
    result := publisher.Publish(ctx, &pubsub.Message{Data: []byte(data)})
    // Don't wait for each - let batching work
}

// Flush remaining messages before stopping
publisher.Flush()
```

## Receiving Messages

### Basic Subscribing

```go
// Get subscriber (can use full name or short name)
subscriber := client.Subscriber("projects/my-project/subscriptions/my-sub")
// OR
subscriber := client.Subscriber("my-sub") // Short form works too

// Configure receive settings (optional)
subscriber.ReceiveSettings.MaxOutstandingMessages = 100
subscriber.ReceiveSettings.MaxOutstandingBytes = 10e6 // 10MB
subscriber.ReceiveSettings.MaxExtension = 30 * time.Second

// Receive messages
err := subscriber.Receive(ctx, func(ctx context.Context, m *pubsub.Message) {
    // Process message
    log.Printf("Received: %s", m.Data)

    // MUST call Ack or Nack within the handler
    m.Ack()
})
if err != nil && !errors.Is(err, context.Canceled) {
    return err
}
```

### Critical Receive Rules

1. **Ack/Nack MUST be called within the handler function**, not from a goroutine
2. **Only one `Receive()` call per subscriber** can be active at a time
3. **Cancel context to stop receiving** - don't call methods on subscriber directly
4. **Messages are processed concurrently** - synchronize access to shared state

```go
// CORRECT: Ack in handler
subscriber.Receive(ctx, func(ctx context.Context, m *pubsub.Message) {
    processMessage(m)
    m.Ack() // ✅ Correct
})

// WRONG: Ack from goroutine
subscriber.Receive(ctx, func(ctx context.Context, m *pubsub.Message) {
    go func() {
        processMessage(m)
        m.Ack() // ❌ Wrong - breaks flow control
    }()
})
```

### Flow Control

Configure `ReceiveSettings` to control resource usage:

```go
subscriber.ReceiveSettings.MaxOutstandingMessages = 100  // Max concurrent messages
subscriber.ReceiveSettings.MaxOutstandingBytes = 10e6    // Max bytes in memory
subscriber.ReceiveSettings.MaxExtension = 30 * time.Second // Max ack deadline extension
```

## Resource Naming

### Full Resource Names

Always use full resource names for admin operations:

- Topics: `"projects/{project-id}/topics/{topic-id}"`
- Subscriptions: `"projects/{project-id}/subscriptions/{subscription-id}"`

### Short Names

For `Publisher()` and `Subscriber()`, you can use short names:

- `client.Publisher("my-topic")` - automatically resolves to current project
- `client.Subscriber("my-sub")` - automatically resolves to current project

**Best Practice:** Use full names when you have the project ID available for clarity and consistency.

## Error Handling

### Iterator Errors

Always check for `iterator.Done` when iterating:

```go
for {
    item, err := it.Next()
    if err == iterator.Done {
        break
    }
    if err != nil {
        return err
    }
    // Process item
}
```

### Context Cancellation

When receiving messages, distinguish between cancellation and errors:

```go
err := subscriber.Receive(ctx, callback)
if err != nil && !errors.Is(err, context.Canceled) {
    // Handle actual error
    return err
}
// Context was canceled - this is normal shutdown
```

### User-Friendly Error Messages

Always provide user-friendly error messages with helpful context:

```go
// ✅ GOOD: Include permission hints and context
if err != nil {
    return fmt.Errorf("failed to create topic %s: %w. Ensure you have 'pubsub.topics.create' permission", topicName, err)
}

// ✅ GOOD: Check for common error types
errStr := err.Error()
if strings.Contains(errStr, "PermissionDenied") || strings.Contains(errStr, "permission denied") {
    return fmt.Errorf("permission denied: you don't have permission to publish to this topic")
}
if strings.Contains(errStr, "NotFound") || strings.Contains(errStr, "not found") {
    return fmt.Errorf("topic not found: the topic '%s' does not exist", topicID)
}

// ❌ BAD: Raw error without context
if err != nil {
    return err
}
```

> **Note:** For CRUD operation error handling patterns, see `topics-and-subs.mdc`.

### Subscription Monitoring Errors

When monitoring subscriptions, handle NotFound errors gracefully (subscription may have been deleted):

```go
err := subscriber.Receive(ctx, callback)
if err != nil {
    // Check if subscription was deleted (expected during cleanup)
    if strings.Contains(err.Error(), "NotFound") || strings.Contains(err.Error(), "not found") {
        // Subscription was deleted - this is expected, exit gracefully
        return nil
    }
    // Handle other errors
    return err
}
```


## CRUD Operations

> **Note:** For resource name normalization patterns, see `topics-and-subs.mdc`.

### Update Operations with Field Masks

When updating subscriptions, use field masks to only update specified fields. See implementation in `internal/pubsub/admin/subscriptions.go:216-309` for the complete `UpdateSubscriptionAdmin` function which demonstrates:
- Getting current subscription
- Cloning with `proto.Clone()`
- Building update mask based on provided parameters
- Creating update request with field mask

### Emitting Events After CRUD Operations

After successful CRUD operations, emit Wails events to notify frontend:

```go
import "github.com/wailsapp/wails/v2/pkg/runtime"

// After creating topic
runtime.EventsEmit(ctx, "topic:created", map[string]interface{}{
    "topicID": topicID,
})

// After deleting topic
runtime.EventsEmit(ctx, "topic:deleted", map[string]interface{}{
    "topicID": topicID,
})

// After updating subscription
runtime.EventsEmit(ctx, "subscription:updated", map[string]interface{}{
    "subscriptionID": subID,
})

// For message streaming (in subscriber callbacks)
runtime.EventsEmit(ctx, "message:received", messageData)

// For monitor errors
runtime.EventsEmit(ctx, "monitor:error", map[string]interface{}{
    "subscriptionID": subID,
    "error":          err.Error(),
})
```

**Event Naming Convention:**

- Use `resource:action` format (e.g., `topic:created`, `subscription:deleted`)
- Use `message:received` for new messages
- Use `monitor:error` for subscription monitoring errors

## Common Patterns

### Graceful Shutdown

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

// Start receiving in goroutine
go func() {
    err := subscriber.Receive(ctx, callback)
    if err != nil && !errors.Is(err, context.Canceled) {
        log.Printf("Receive error: %v", err)
    }
}()

// Later, to stop:
cancel() // This will gracefully stop Receive()
```

### Message Attributes

```go
msg := &pubsub.Message{
    Data: []byte("payload"),
    Attributes: map[string]string{
        "source": "api",
        "version": "1.0",
        "timestamp": time.Now().Format(time.RFC3339),
    },
}
```

### Duration Handling

When working with protobuf duration fields:

```go
import "google.golang.org/protobuf/types/known/durationpb"

// Convert from protobuf duration
if topic.MessageRetentionDuration != nil {
    duration := topic.MessageRetentionDuration.AsDuration()
    // Use duration
}

// Convert to protobuf duration
retention := durationpb.New(7 * 24 * time.Hour)
```

## Connection Management

> **Note:** For connection profiles and authentication, see `auth.mdc`.

### Client Manager Best Practices

The `ClientManager` handles client lifecycle and is **thread-safe**:

- **SetClient**: Closes existing client before setting new one (thread-safe with mutex)
- **Close**: Properly closes client and clears project ID (thread-safe)
- **IsConnected**: Thread-safe check for active connection
- **GetClient**: Thread-safe access to current client
- **GetProjectID**: Thread-safe access to current project ID

**Always use ClientManager methods** - never manipulate client directly:

```go
// ✅ CORRECT: Use ClientManager
client := a.clientManager.GetClient()
if client == nil {
    return models.ErrNotConnected
}

projectID := a.clientManager.GetProjectID()
if projectID == "" {
    return fmt.Errorf("no project ID available")
}

// ❌ WRONG: Direct client access (not thread-safe)
client := a.client // Don't do this
projectID := a.projectID // Don't do this
```

### Resource Loading After Connection

When loading resources (topics, subscriptions) after connecting:

1. **Verify Connection**: Check `IsConnected()` before loading
2. **Get Project ID**: Use `GetProjectID()` to ensure it matches expected project
3. **Handle Errors**: Clear resources on error to prevent stale data

**Implementation:**

See `app.go:305-314` for the `ListTopics` method which demonstrates:
- Getting client via `ClientManager`
- Checking connection status
- Getting project ID
- Calling admin function

## Migration from v1

If migrating from v1, note these key differences:

- Use `client.TopicAdminClient` instead of `client.Topic()`
- Use `client.SubscriptionAdminClient` instead of `client.Subscription()`
- Use `client.Publisher()` and `client.Subscriber()` for pub/sub operations
- Message handling is similar but API surface changed

See: <https://github.com/googleapis/google-cloud-go/blob/main/pubsub/MIGRATING.md>
