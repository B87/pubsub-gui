---
alwaysApply: true
---
# UI Development Guide for Pub/Sub GUI

This guide covers UI development patterns, conventions, and best practices for the Pub/Sub GUI desktop application.

## Tech Stack

- **Framework**: React 18 with TypeScript
- **Styling**: Tailwind CSS v4 (using `@tailwindcss/postcss`)
- **UI Component Library**: shadcn/ui (built on Radix UI primitives)
- **UI Primitives**: Radix UI (accessible, unstyled primitives)
- **Build Tool**: Vite 3
- **Desktop Framework**: Wails v2 (Go backend + React frontend)

## Project Structure

```
frontend/src/
├── components/          # React components
│   ├── Layout.tsx      # Main layout wrapper (sidebar + main)
│   ├── Sidebar.tsx     # Resource navigation sidebar
│   ├── TopicDetails.tsx
│   ├── SubscriptionDetails.tsx
│   └── ...
├── types/              # TypeScript type definitions
│   └── index.ts
├── wailsjs/           # Auto-generated Wails bindings (DO NOT EDIT)
│   └── go/main/App.js
├── App.tsx            # Root component
├── main.tsx           # React entry point
└── style.css          # Global styles + Tailwind imports
```

## Component Patterns

> **Note:** For Wails-specific patterns (method binding, events, context), see `wails.mdc` Frontend Patterns section.

### Component Structure

```typescript
import { useState, useEffect } from 'react';
import type { Topic } from '../types';
import { SomeWailsMethod } from '../wailsjs/go/main/App';

interface ComponentProps {
  topic: Topic;
  onAction?: () => void;
}

export default function Component({ topic, onAction }: ComponentProps) {
  const [state, setState] = useState<string>('');

  useEffect(() => {
    // Side effects
  }, [topic]);

  return (
    <div className="...">
      {/* Component JSX */}
    </div>
  );
}
```

### Component Creation Checklist

**CRITICAL**: Before creating or modifying any component, ensure:

**Theme System Compliance:**
> **Note:** For complete theme system documentation, see `theme-system.mdc`.

- [ ] All colors use semantic CSS variables (`var(--color-*)`) via inline styles or custom CSS classes
- [ ] NO hardcoded colors (`style={{ color: '#fff' }}` or `bg-[#...]`)
- [ ] Tailwind classes only used as fallback when semantic styling isn't practical
- [ ] Opacity variants use `color-mix()` with CSS variables (e.g., `color-mix(in srgb, var(--color-bg-primary) 30%, transparent)`)
- [ ] All components tested with all 5 themes to ensure proper appearance

**Layout & Structure:**
- [ ] For full-height tabs: Use flexbox layout with sticky header pattern (see Advanced Layout Patterns)
- [ ] For filter dropdowns: Ensure parent containers have `overflow: visible` to prevent clipping
- [ ] For scrollable content: Use `flex-1 overflow-y-auto` with `min-h-0` for proper scrolling
- [ ] For sticky headers: Use `backdrop-blur` with semi-transparent background for modern look

**Testing:**
- [ ] Component tested visually in Dark theme (default)
- [ ] Component tested in Light theme (check contrast)
- [ ] Component tested in Dracula theme (purple accent)
- [ ] Component tested in Monokai theme (cyan accent)
- [ ] Component works with "Auto" theme (system preference)
- [ ] Dropdowns and tooltips are not clipped by parent containers
- [ ] Scrollable areas work correctly and don't create double scrollbars

**Common Issues to Avoid:**
- Border/hover colors not adapting to theme
- Text contrast too low in Light theme
- Status colors (success/error/warning) hardcoded
- Modal/dialog backgrounds not using theme variables
- Accent colors hardcoded to blue (should use theme accent)
- Unicode characters (e.g., → U+2192) causing parsing errors - use ASCII alternatives (e.g., `-` or `->`)
- Hardcoded `color: 'white'` on colored backgrounds - use `var(--color-text-primary)` for theme compatibility
- Dropdowns being clipped by parent `overflow: hidden` - use `overflow: visible` on filter containers
- Double scrollbars from nested scrollable containers - use `overflow: hidden` on outer container

### Naming Conventions

- **Components**: PascalCase, descriptive names (e.g., `TopicDetails`, `ConnectionDialog`)
- **Files**: Match component name (e.g., `TopicDetails.tsx`)
- **Props interfaces**: `ComponentNameProps` (e.g., `TopicDetailsProps`)
- **Types**: PascalCase, exported from `types/index.ts`

## TypeScript Best Practices

### Nullish Coalescing (`??`) vs Logical OR (`||`)

**CRITICAL**: Prefer using the nullish coalescing operator (`??`) instead of logical OR (`||`) for default values, as it is safer and more precise.

**Key Difference:**
- `??` only checks for `null` or `undefined`
- `||` checks for any falsy value (`null`, `undefined`, `0`, `''`, `false`, `NaN`)

**When to Use `??` (Default Values):**

```tsx
// ✅ CORRECT: Use ?? for default values when you want to preserve falsy values
const name = profile?.name ?? '';
const projectId = profile?.projectId ?? '';
const authMethod = profile?.authMethod ?? 'ADC';
const isDefault = profile?.isDefault ?? false;
const port = managedConfig.port ?? 8085;
const createdAt = profile?.createdAt ?? new Date().toISOString();

// ✅ CORRECT: Use ?? for optional object properties
const managedEmulator = profile?.managedEmulator ?? { ...defaultManagedConfig };
const image = managedConfig.image ?? '';
const dataDir = managedConfig.dataDir ?? '';
```

**When to Use `||` (Legitimate Cases):**

```tsx
// ✅ CORRECT: Use || when you want to handle falsy values (including 0, '', false)
// Example: parseInt can return NaN, and we want to handle NaN as well
const port = parseInt(e.target.value) || 8085; // NaN || 8085 works, NaN ?? 8085 would return NaN

// ✅ CORRECT: Use || for boolean logic (not default values)
if (error || externalError) {
  // Show error if either exists
}

// ✅ CORRECT: Use || for conditional rendering
{(error || externalError) && (
  <Alert>{error || externalError}</Alert>
)}

// ✅ CORRECT: Use || for logical conditions in disabled props
disabled={
  saving ||
  !formData.name.trim() ||
  !formData.projectId.trim()
}
```

**Anti-Patterns:**

```tsx
// ❌ WRONG: Using || for default values (can cause bugs with falsy values)
const name = profile?.name || ''; // If name is '', this works but is less clear
const isDefault = profile?.isDefault || false; // If isDefault is false, this works but is less clear
const port = managedConfig.port || 8085; // If port is 0, this incorrectly uses 8085!

// ✅ CORRECT: Use ?? for default values
const name = profile?.name ?? '';
const isDefault = profile?.isDefault ?? false;
const port = managedConfig.port ?? 8085; // If port is 0, it correctly uses 0
```

**Summary:**
- **Use `??`** for default value assignments (when you want to preserve `0`, `''`, `false`)
- **Use `||`** for boolean logic, conditional rendering, and cases where you want to handle all falsy values (like `NaN` from `parseInt`)

## Styling Guidelines

### Theme System

> **Note:** For complete theme system documentation including architecture, implementation patterns, and Monaco Editor integration, see `theme-system.mdc`.

**CRITICAL**: This application uses a comprehensive theme system with 5 themes (Auto, Dark, Light, Dracula, Monokai) and 3 font sizes. **ALL components MUST use the theme system.**

**Core Requirements:**
1. **NEVER use hardcoded colors** - Always use semantic CSS variables
2. **PRIORITIZE semantic style format** - Use CSS custom properties directly via inline styles or custom CSS classes
3. **Tailwind classes are fallback** - Only use Tailwind utility classes when semantic styling isn't practical
4. **Test with multiple themes** - Components should work correctly in all 5 themes

**Quick Reference - Semantic CSS Variables:**

```typescript
// ✅ PREFERRED: Use semantic CSS variables directly
<div style={{ backgroundColor: 'var(--color-bg-primary)' }}>...</div>
<div style={{ color: 'var(--color-text-primary)' }}>...</div>
<div style={{ borderColor: 'var(--color-border-primary)' }}>...</div>
```

**Common Variables:**
- Backgrounds: `--color-bg-primary`, `--color-bg-secondary`, `--color-bg-tertiary`, `--color-bg-input`, `--color-bg-code`
- Text: `--color-text-primary`, `--color-text-secondary`, `--color-text-muted`
- Borders: `--color-border-primary`, `--color-border-secondary`
- Accents: `--color-accent-primary`, `--color-accent-hover`
- Status: `--color-success`, `--color-error`, `--color-warning` (with `-bg`, `-border`, `-hover` variants)

**Tailwind Classes (FALLBACK):**
```typescript
// ⚠️ FALLBACK: Use Tailwind classes only when semantic styling isn't practical
<div className="bg-slate-800">...</div>  // Maps to var(--color-bg-secondary)
<div className="text-slate-100">...</div> // Maps to var(--color-text-primary)
```

**Anti-Patterns:**
```tsx
// ❌ WRONG: Hardcoded colors (breaks theme system)
<div style={{ backgroundColor: '#1e293b' }}>...</div>
<div className="bg-[#1e293b]">...</div>

// ✅ PREFERRED: Semantic CSS variables
<div style={{ backgroundColor: 'var(--color-bg-secondary)' }}>...</div>
```

### Tailwind CSS v4 Usage

This project uses **Tailwind CSS v4** with the new `@import "tailwindcss"` syntax.

**Key Principles:**
1. **PRIORITIZE semantic CSS variables** - Use `var(--color-*)` via inline styles or custom CSS classes
2. **Tailwind for layout/spacing** - Use Tailwind utilities for spacing (p-4, m-2, gap-3), layout (flex, grid), and sizing (w-full, h-screen)
3. **Tailwind classes as fallback** - Only use Tailwind color classes when semantic styling isn't practical
4. **Theme system compliance** - All color styling must use theme variables for compatibility with all 5 themes
5. **Consistent spacing**: Use Tailwind's spacing scale (p-4, m-2, gap-3, etc.)
6. **Responsive design**: Not required for desktop app, but maintain consistent sizing

### Common Patterns

**Buttons:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Button component (wrapper with loading support)
import { Button } from './ui';

<Button onClick={handleSubmit} loading={isSaving}>
  Submit
</Button>

<Button variant="outline" onClick={handleCancel}>
  Cancel
</Button>

<Button variant="ghost" onClick={handleDisconnect}>
  Disconnect
</Button>

<Button variant="destructive" onClick={handleDelete}>
  Delete
</Button>

// Button variants: default, destructive, outline, secondary, ghost, link
// Button sizes: default, sm, lg, icon
```

**Input Fields:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Input component (wrapper with error support)
import { Input, FormField } from './ui';

// With FormField wrapper (recommended for forms)
<FormField
  label="Project ID"
  required
  error={errors.projectId}
  helperText="Enter your GCP project ID"
>
  <Input
    value={projectId}
    onChange={(e) => setProjectId(e.target.value)}
    error={!!errors.projectId}
    placeholder="my-project-id"
  />
</FormField>

// Standalone Input
<Input
  value={value}
  onChange={(e) => setValue(e.target.value)}
  error={validationError}
  placeholder="Enter text..."
/>
```

**Select Dropdowns:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Select component (native, CSS variables mapped)
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue, FormField } from './ui';

<FormField label="Topic" required>
  <Select value={selectedTopic} onValueChange={setSelectedTopic}>
    <SelectTrigger>
      <SelectValue placeholder="Select a topic" />
    </SelectTrigger>
    <SelectContent>
      {topics.map((topic) => (
        <SelectItem key={topic.name} value={topic.name}>
          {topic.displayName}
        </SelectItem>
      ))}
    </SelectContent>
  </Select>
</FormField>
```

**CRITICAL: Select Item Values Cannot Be Empty Strings**

Radix UI Select (which shadcn/ui Select is built on) **does not allow empty string values** for `SelectItem`. The Select component uses empty strings internally to clear the selection and show the placeholder.

**Pattern for Optional/None Selections:**

When you need a "None" or optional selection option, use a sentinel value and convert it in the handler:

```tsx
// ✅ CORRECT: Use sentinel value for "None" option
const [deadLetterTopic, setDeadLetterTopic] = useState('');

<Select
  value={deadLetterTopic || 'none'}
  onValueChange={(value) => setDeadLetterTopic(value === 'none' ? '' : value)}
>
  <SelectTrigger>
    <SelectValue placeholder="Select a topic..." />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="none">None</SelectItem>
    {topics.map((topic) => (
      <SelectItem key={topic.name} value={topic.name}>
        {topic.displayName}
      </SelectItem>
    ))}
  </SelectContent>
</Select>

// In save handler, empty string is already handled correctly:
if (deadLetterTopic.trim() && maxDeliveryAttempts.trim()) {
  params.deadLetterPolicy = {
    deadLetterTopic: deadLetterTopic.trim(),
    maxDeliveryAttempts: maxAttempts,
  };
}
```

**Key Points:**
- Use a simple sentinel value like `"none"` (not `"__none__"` - keep it simple)
- Convert sentinel value to empty string in `onValueChange` handler: `value === 'none' ? '' : value`
- Convert empty string to sentinel value in `value` prop: `value={state || 'none'}`
- Your save/validation logic should already handle empty strings correctly (check with `.trim()`)

**Anti-Pattern:**
```tsx
// ❌ WRONG: Empty string value causes error
<SelectItem value="">None</SelectItem>
// Error: "A <Select.Item /> must have a value prop that is not an empty string"
```

**Alternative Patterns:**

1. **No "None" Option** (if clearing isn't needed):
```tsx
// Just use placeholder, no explicit "None" option
<Select value={selectedTopic || undefined}>
  <SelectValue placeholder="Select a topic..." />
  {/* No "None" SelectItem */}
</Select>
```

2. **Checkbox Pattern** (for optional features):
```tsx
// Better UX for optional features - use checkbox to enable/disable
const [enableDeadLetter, setEnableDeadLetter] = useState(false);

{enableDeadLetter && (
  <Select value={deadLetterTopic} onValueChange={setDeadLetterTopic}>
    {/* No "None" option needed */}
  </Select>
)}
```

**Cards/Panels:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Card component (native, CSS variables mapped)
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from './ui';

<Card>
  <CardHeader>
    <CardTitle>Card Title</CardTitle>
    <CardDescription>Card description text</CardDescription>
  </CardHeader>
  <CardContent>
    {/* Card content */}
  </CardContent>
  <CardFooter>
    <Button>Action</Button>
  </CardFooter>
</Card>
```

**Loading States:**
```tsx
// ✅ PREFERRED: Use Button loading prop (wrapper feature)
import { Button } from './ui';

<Button loading={isSaving} onClick={handleSave}>
  {isSaving ? 'Saving...' : 'Save'}
</Button>

// Loading state automatically:
// - Shows spinner icon
// - Disables button
// - Prevents multiple clicks
```

**Alerts/Error Messages:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Alert component (wrapper with variants)
import { Alert, AlertTitle, AlertDescription } from './ui';

// Success message
<Alert variant="success">
  <AlertTitle>Success</AlertTitle>
  <AlertDescription>Operation completed successfully.</AlertDescription>
</Alert>

// Error message
<Alert variant="destructive">
  <AlertTitle>Error</AlertTitle>
  <AlertDescription>{errorMessage}</AlertDescription>
</Alert>

// Warning message
<Alert variant="warning">
  <AlertTitle>Warning</AlertTitle>
  <AlertDescription>Please review your settings.</AlertDescription>
</Alert>

// Alert variants: default, destructive, success, warning
```

## shadcn/ui Component Library

This project uses **shadcn/ui** as the primary UI component library. shadcn/ui provides accessible, customizable components built on Radix UI primitives and styled with Tailwind CSS.

**Component Location:** All UI components are in `frontend/src/components/ui/`

**Import Pattern:**
```typescript
// ✅ CORRECT: Import from './ui' (barrel export)
import { Button, Input, Select, Dialog, Alert, Badge, Card, FormField } from './ui';
```

### Wrapper vs Native Components

**CRITICAL**: The codebase uses a **wrapper pattern** for shadcn/ui components. Some components have wrappers that add theme support or additional features, while others use native shadcn components directly.

**When to Use Wrappers:**
- **Button** - Use wrapper (`Button` from `./ui`) - adds `loading` prop support
- **Dialog** - Use wrapper (`Dialog`, `DialogContent`, etc. from `./ui`) - applies theme CSS variables
- **Input** - Use wrapper (`Input` from `./ui`) - adds `error` prop support
- **Alert** - Use wrapper (`Alert` from `./ui`) - adds `success` and `warning` variants
- **Badge** - Use wrapper (`Badge` from `./ui`) - adds `success` and `warning` variants
- **FormField** - Use wrapper (`FormField` from `./ui`) - custom component for form fields with label/error/helper text

**When to Use Native shadcn:**
- **Select** - Use native (`Select`, `SelectTrigger`, `SelectContent`, etc. from `./ui`) - CSS variables mapped in `themes.css`
- **Label** - Use native (`Label` from `./ui`) - CSS variables handle styling
- **Card** - Use native (`Card`, `CardHeader`, `CardContent`, etc. from `./ui`) - CSS variables handle styling
- **Checkbox** - Use native (`Checkbox` from `./ui`) - CSS variables handle styling
- **RadioGroup** - Use native (`RadioGroup`, `RadioGroupItem` from `./ui`) - CSS variables handle styling
- **Separator** - Use native (`Separator` from `./ui`) - CSS variables handle styling

**Why Wrappers?**
- Wrappers preserve original shadcn components (easier to update)
- Wrappers add app-specific features (loading states, error handling, custom variants)
- Wrappers ensure theme compatibility via CSS variables
- Native components work when CSS variables are properly mapped in `themes.css`

**Component Usage Examples:**

```tsx
// ✅ Button with loading state (wrapper)
import { Button } from './ui';

<Button loading={isSaving} onClick={handleSave}>
  Save
</Button>

// ✅ Input with error state (wrapper)
import { Input } from './ui';

<Input
  value={value}
  onChange={(e) => setValue(e.target.value)}
  error={validationError}
/>

// ✅ Select dropdown (native shadcn)
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from './ui';

<Select value={selected} onValueChange={setSelected}>
  <SelectTrigger>
    <SelectValue placeholder="Choose option" />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="option1">Option 1</SelectItem>
    <SelectItem value="option2">Option 2</SelectItem>
  </SelectContent>
</Select>

// ✅ Alert with variants (wrapper)
import { Alert, AlertTitle, AlertDescription } from './ui';

<Alert variant="success">
  <AlertTitle>Success</AlertTitle>
  <AlertDescription>Operation completed successfully.</AlertDescription>
</Alert>

<Alert variant="destructive">
  <AlertTitle>Error</AlertTitle>
  <AlertDescription>{errorMessage}</AlertDescription>
</Alert>

// ✅ FormField with label and error (wrapper)
import { FormField, Input } from './ui';

<FormField
  label="Project ID"
  required
  error={errors.projectId}
  helperText="Enter your GCP project ID"
>
  <Input
    value={projectId}
    onChange={(e) => setProjectId(e.target.value)}
    error={!!errors.projectId}
  />
</FormField>

// ✅ Dialog (wrapper)
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, Button } from './ui';

<Dialog open={isOpen} onOpenChange={setIsOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Confirm Action</DialogTitle>
    </DialogHeader>
    <p>Are you sure?</p>
    <DialogFooter>
      <Button variant="outline" onClick={() => setIsOpen(false)}>Cancel</Button>
      <Button onClick={handleConfirm}>Confirm</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**Available Components:**

All components are exported from `frontend/src/components/ui/index.ts`:

**Wrappers (with additional features):**
- `Button` - Adds `loading` prop
- `Dialog`, `DialogContent`, `DialogHeader`, `DialogTitle`, `DialogDescription`, `DialogFooter`, `DialogTrigger`, `DialogClose`, `DialogPortal` - Theme CSS variables
- `Input` - Adds `error` prop
- `Alert`, `AlertTitle`, `AlertDescription` - Adds `success` and `warning` variants
- `Badge` - Adds `success` and `warning` variants
- `FormField` - Custom component for form fields

**Native shadcn (no wrapper needed):**
- `Select`, `SelectTrigger`, `SelectContent`, `SelectItem`, `SelectValue`, `SelectGroup`, `SelectLabel`, `SelectSeparator`
- `Label`
- `Card`, `CardHeader`, `CardFooter`, `CardTitle`, `CardDescription`, `CardContent`
- `Checkbox`
- `RadioGroup`, `RadioGroupItem`
- `Separator`

## Radix UI Integration

Radix UI provides accessible, unstyled primitives that shadcn/ui builds upon. **PREFER shadcn/ui components** over raw Radix UI primitives for consistency.

**Radix Components Available:**
- `@radix-ui/react-tabs` - ✅ **Used** in `SubscriptionDetails.tsx` for tabbed interfaces
- `@radix-ui/react-dialog` - ✅ **Used** via shadcn/ui Dialog wrapper
- `@radix-ui/react-select` - ✅ **Used** via shadcn/ui Select component
- `@radix-ui/react-label` - ✅ **Used** via shadcn/ui Label component
- `@radix-ui/react-separator` - ✅ **Used** via shadcn/ui Separator component
- `@radix-ui/react-dropdown-menu` - Available for dropdown menus (not yet used)

**Example - Dialog (PREFERRED Pattern):**
```tsx
// ✅ PREFERRED: Use shadcn/ui Dialog component (wrapper with theme support)
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription, Button } from './ui';

interface DialogProps {
  open: boolean;
  onClose: () => void;
}

export default function CustomDialog({ open, onClose }: DialogProps) {
  return (
    <Dialog open={open} onOpenChange={(open) => !open && onClose()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Dialog Title</DialogTitle>
          <DialogDescription>Dialog description text</DialogDescription>
        </DialogHeader>
        {/* Content */}
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleSave}>Save</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**Example - Radix Tabs (PREFERRED Pattern):**
```tsx
import * as Tabs from '@radix-ui/react-tabs';

// Use CSS for active state styling
<style>{`
  [data-state="active"] {
    color: var(--color-text-primary) !important;
    border-bottom-color: var(--color-accent-primary) !important;
  }
`}</style>

<Tabs.Root value={activeTab} onValueChange={setActiveTab}>
  <Tabs.List
    style={{ borderBottomColor: 'var(--color-border-primary)' }}
    className="flex border-b"
  >
    <Tabs.Trigger
      value="tab1"
      style={{
        color: 'var(--color-text-secondary)',
        borderBottomWidth: '2px',
        borderBottomStyle: 'solid',
        borderBottomColor: 'transparent',
      }}
      className="px-4 py-2 transition-colors"
    >
      Tab 1
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="tab1">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Wails Integration

> **Note:** For comprehensive Wails patterns including backend-frontend communication, event handling, and method binding, see `wails.mdc`.

### Quick Reference

**Importing Wails Methods:**
```typescript
import { MethodName } from '../wailsjs/go/main/App';
const result = await MethodName(param1, param2);
```

**Important:** Wails TypeScript bindings are **auto-generated** when you run `wails dev` or `wails build`. The `frontend/wailsjs/` directory contains generated code - **DO NOT EDIT** these files.

**Available Methods** (from `wailsjs/go/main/App.d.ts`):

**Connection Management:**
- `ConnectWithADC(projectID: string)` - Connect using Application Default Credentials
- `ConnectWithServiceAccount(projectID: string, keyPath: string)` - Connect using service account JSON
- `GetConnectionStatus()` - Get current connection status
- `Disconnect()` - Disconnect from current project
- `SwitchProfile(profileId: string)` - Switch to a different connection profile

**Profiles:**
- `GetProfiles()` - Get all connection profiles
- `SaveProfile(profile: ConnectionProfile)` - Save a connection profile
- `DeleteProfile(profileId: string)` - Delete a connection profile

**Topics:**
- `ListTopics()` - List all topics in the project
- `GetTopicMetadata(topicID: string)` - Get topic metadata
- `CreateTopic(topicID: string, messageRetentionDuration: string)` - Create a new topic
- `DeleteTopic(topicID: string)` - Delete a topic

**Subscriptions:**
- `ListSubscriptions()` - List all subscriptions in the project
- `GetSubscriptionMetadata(subID: string)` - Get subscription metadata
- `CreateSubscription(topicID: string, subID: string, ttlSeconds: number)` - Create a subscription
- `UpdateSubscription(subID: string, params: SubscriptionUpdateParams)` - Update subscription settings
- `DeleteSubscription(subID: string)` - Delete a subscription

**Publishing:**
- `PublishMessage(topicID: string, payload: string, attributes: Record<string, string>)` - Publish a message

**Monitoring:**
- `StartMonitor(subID: string)` - Start monitoring a subscription
- `StopMonitor(subID: string)` - Stop monitoring a subscription
- `StartTopicMonitor(topicID: string)` - Start monitoring a topic (creates temp subscription)
- `StopTopicMonitor(topicID: string)` - Stop topic monitoring
- `GetBufferedMessages(subID: string)` - Get buffered messages for a subscription
- `ClearMessageBuffer(subID: string)` - Clear message buffer
- `GetAutoAck()` - Get auto-acknowledge setting
- `SetAutoAck(enabled: boolean)` - Set auto-acknowledge setting

**Templates:**
- `GetTemplates(topicID: string)` - Get message templates (optionally filtered by topic)
- `SaveTemplate(template: MessageTemplate)` - Save a message template
- `UpdateTemplate(templateID: string, template: MessageTemplate)` - Update a template
- `DeleteTemplate(templateID: string)` - Delete a template

**Configuration:**
- `GetConfigFileContent()` - Get raw config file content
- `SaveConfigFileContent(content: string)` - Save config file content

### Listening to Go Events

> **Note:** For comprehensive event listening patterns, see `wails.mdc` Frontend Patterns section.

```typescript
import { EventsOn } from '../wailsjs/runtime/runtime';

useEffect(() => {
  const unsubscribe = EventsOn('event:name', (data) => {
    // Handle event
  });

  return () => unsubscribe();
}, []);
```

**Common Events:**
- `message:received` - New message received during monitoring (topic or subscription)
- `monitor:started` - Monitoring started for a subscription
- `monitor:stopped` - Monitoring stopped for a subscription
- `monitor:error` - Error during monitoring
- `topic:created`, `topic:deleted` - Topic lifecycle events
- `subscription:created`, `subscription:updated`, `subscription:deleted` - Subscription lifecycle events
- `connection:success` - Connection established successfully
- `config:theme-changed` - Theme configuration changed (see `theme-system.mdc`)
- `config:font-size-changed` - Font size configuration changed (see `theme-system.mdc`)
- `resources:updated` - Resource cache synchronized (see `wails.mdc`)
- `resources:sync-error` - Error during resource synchronization (partial failures)

### Error Handling

> **Note:** For basic Wails error handling patterns, see `wails.mdc`. For comprehensive UI error display patterns, see Error Display section below.

## Type Safety

### Type Definitions

All types are defined in `frontend/src/types/index.ts`:

```typescript
export interface Topic {
  name: string;
  displayName: string;
  messageRetention?: string;
}

export interface Subscription {
  name: string;
  displayName: string;
  topic: string;
  // ...
}
```

**Always:**
- Import types from `types/index.ts`
- Use TypeScript interfaces for props
- Type Wails method return values (use `as` if needed for auto-generated types)

## Layout Structure

The app uses a consistent layout pattern:

```tsx
<Layout sidebar={<Sidebar ... />}>
  {/* Main content */}
</Layout>
```

**Layout Component:**
- Fixed sidebar (320px width, `w-80`)
- Flexible main content area
- Use semantic CSS variables for backgrounds (`var(--color-bg-primary)`, `var(--color-bg-secondary)`)

## State Management

> **Note:** For Wails-specific state patterns (resource synchronization, event-driven updates), see `wails.mdc` Common Patterns section.

**Current Approach:** React `useState` and `useEffect` (no global state library)

**Patterns:**
- Lift state up to `App.tsx` for shared state (connection status, resources)
- Use local state for component-specific UI state
- Pass callbacks down for actions

**Example:**
```tsx
// In App.tsx
const [topics, setTopics] = useState<Topic[]>([]);
const handleSelectTopic = (topic: Topic) => {
  setSelectedResource({ type: 'topic', id: topic.name });
};

// Pass to child
<TopicDetails topic={topic} />
```

### Async State Management & Connection Switching

**CRITICAL: Always follow these patterns when switching connections or profiles:**

1. **Clear State Immediately**: Always clear dependent state (resources, selections) at the START of any connection switch operation, before any async operations begin.

2. **Proper Async Sequencing**: Always `await` all async operations in sequence. Never call async functions without awaiting them, especially when loading resources after connection changes.

3. **Connection Verification**: After switching connections, verify the connection status and project ID match expectations before loading resources.

4. **Defensive State Updates**: Only update state with new data if the connection is still valid. Check connection status before setting resources.

**Example - Profile Switching Pattern:**
```tsx
const handleProfileSwitch = async () => {
  // 1. Clear state IMMEDIATELY (before any async operations)
  setTopics([]);
  setSubscriptions([]);
  setSelectedResource(null);
  setError('');
  setLoadingResources(true);

  try {
    // 2. Wait for backend operation to complete
    await SwitchProfile(profileId);

    // 3. Get new connection status
    const newStatus = await GetConnectionStatus();
    setStatus(newStatus);

    // 4. Verify connection before loading resources
    if (newStatus.isConnected) {
      // Small delay to ensure backend connection is fully established
      await new Promise(resolve => setTimeout(resolve, 300));

      // 5. Double-check connection still matches
      const verifyStatus = await GetConnectionStatus();
      if (verifyStatus.isConnected && verifyStatus.projectId === newStatus.projectId) {
        // 6. Only then load resources
        await loadResources(); // MUST be awaited
      }
    }
  } catch (e: any) {
    // 7. Clear resources on error to prevent stale data
    setTopics([]);
    setSubscriptions([]);
    setError('Failed to reload resources: ' + e.toString());
  } finally {
    setLoadingResources(false);
  }
};
```

**Example - Resource Loading Pattern:**
```tsx
const loadResources = async () => {
  setLoadingResources(true);
  setError('');

  try {
    // Clear resources first to prevent showing stale data
    setTopics([]);
    setSubscriptions([]);

    const [topicsData, subsData] = await Promise.all([
      ListTopics(),
      ListSubscriptions()
    ]);

    // Verify connection is still valid before setting resources
    const currentStatus = await GetConnectionStatus();
    if (currentStatus.isConnected) {
      setTopics(topicsData as any || []);
      setSubscriptions(subsData as any || []);
    }
  } catch (e: any) {
    setError('Failed to load resources: ' + e.toString());
    // Clear resources on error
    setTopics([]);
    setSubscriptions([]);
  } finally {
    setLoadingResources(false);
  }
};
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Not awaiting async operations
const loadStatus = async () => {
  const s = await GetConnectionStatus();
  setStatus(s);
  if (s.isConnected) {
    loadResources(); // ❌ Not awaited - creates race condition!
  }
};

// ❌ WRONG: Not clearing state before async operations
const handleProfileSwitch = async () => {
  await SwitchProfile(profileId);
  await loadStatus(); // ❌ Old resources still in state!
};

// ❌ WRONG: Not verifying connection before loading
const handleProfileSwitch = async () => {
  setTopics([]); // Good
  await SwitchProfile(profileId);
  await loadResources(); // ❌ May load from wrong connection if switch not complete
};

// ✅ CORRECT: Clear, verify, then load
const handleProfileSwitch = async () => {
  setTopics([]); // Clear immediately
  setSubscriptions([]);
  await SwitchProfile(profileId); // Wait for switch
  const status = await GetConnectionStatus(); // Verify
  if (status.isConnected) {
    await loadResources(); // Load only if verified
  }
};
```

**Key Rules:**
- **Always clear dependent state first** when starting any connection/context switch
- **Always await async operations** - never fire-and-forget async calls that update state
- **Always verify connection** before loading resources after a switch
- **Always clear state on errors** to prevent displaying stale data
- **Use loading states** to prevent UI updates during transitions

## User Action Patterns

### Manual vs Automatic Actions

**CRITICAL**: Always prefer manual user actions over automatic actions for operations that:
- Consume resources (network, CPU, memory)
- Create or modify resources
- Start background processes
- May fail and need user awareness

**Pattern: Manual Action with Button**
```tsx
// ✅ CORRECT: User clicks button to start monitoring
const [isMonitoring, setIsMonitoring] = useState(false);
const [error, setError] = useState('');

const handleStartMonitoring = async () => {
  setError('');
  try {
    await StartMonitoring();
    setIsMonitoring(true);
  } catch (err) {
    setError('Failed to start monitoring: ' + err.toString());
  }
};

return (
  <div>
    {!isMonitoring ? (
      <button onClick={handleStartMonitoring}>Start Monitoring</button>
    ) : (
      <span>Monitoring...</span>
    )}
    {error && <div className="error">{error}</div>}
  </div>
);
```

**Anti-Pattern: Automatic Action**
```tsx
// ❌ WRONG: Automatically starts monitoring when component mounts
useEffect(() => {
  StartMonitoring(); // Starts without user action!
}, [topic]);
```

**When Automatic Actions Are Acceptable:**
- Loading data for display (e.g., loading topic metadata)
- Setting up event listeners
- Initializing UI state
- Loading saved preferences

**When Manual Actions Are Required:**
- Starting monitoring/streaming
- Publishing messages
- Creating/deleting resources
- Connecting to services
- Any operation that may fail and needs user awareness

## Connection Dialog Patterns

### ConnectionDialog Component

The `ConnectionDialog` component provides UI for connecting to GCP Pub/Sub with different authentication methods.

**Location:** `frontend/src/components/ConnectionDialog.tsx`

**Authentication Methods:**
- **ADC**: Application Default Credentials (default)
- **Service Account**: JSON key file path required
- **OAuth**: OAuth client JSON path required

**Component Structure:**
```tsx
interface ConnectionDialogProps {
  open: boolean;
  onConnect: (
    projectId: string,
    authMethod: 'ADC' | 'ServiceAccount' | 'OAuth',
    serviceAccountPath?: string,
    oauthClientPath?: string,
    saveAsProfile?: { name: string; isDefault?: boolean }
  ) => Promise<void>;
  onClose: () => void;
  error?: string;
}
```

**Theme Compliance:**
- Uses semantic CSS variables for all colors
- Backdrop uses `color-mix(in srgb, var(--color-bg-primary) 50%, transparent)`
- Error messages use `var(--color-error-bg)`, `var(--color-error-border)`, `var(--color-error)`
- Buttons use theme-aware accent colors

**Validation:**
- Project ID is required for all methods
- Service Account path required when `authMethod === 'ServiceAccount'`
- OAuth client path required when `authMethod === 'OAuth'`
- Profile name required if `saveAsProfile` is enabled

**Usage Example:**
```tsx
const handleConnect = async (
  projectId: string,
  authMethod: 'ADC' | 'ServiceAccount' | 'OAuth',
  serviceAccountPath?: string,
  oauthClientPath?: string,
  saveAsProfile?: { name: string; isDefault?: boolean }
) => {
  setError('');
  setLoading(true);
  try {
    if (authMethod === 'ADC') {
      await ConnectWithADC(projectId);
    } else if (authMethod === 'ServiceAccount') {
      if (!serviceAccountPath) {
        throw new Error('Service account path is required');
      }
      await ConnectWithServiceAccount(projectId, serviceAccountPath);
    } else if (authMethod === 'OAuth') {
      if (!oauthClientPath) {
        throw new Error('OAuth client path is required');
      }
      await ConnectWithOAuth(projectId, oauthClientPath);
    }

    // Save as profile if requested
    if (saveAsProfile) {
      const profile: ConnectionProfile = {
        id: Date.now().toString(),
        name: saveAsProfile.name,
        projectId: projectId,
        authMethod: authMethod,
        serviceAccountPath: authMethod === 'ServiceAccount' ? serviceAccountPath : undefined,
        oauthClientPath: authMethod === 'OAuth' ? oauthClientPath : undefined,
        isDefault: saveAsProfile.isDefault || false,
        createdAt: new Date().toISOString(),
      };
      await SaveProfile(profile);
    }

    await loadStatus();
    onClose();
  } catch (e: any) {
    setError(e.toString());
  } finally {
    setLoading(false);
  }
};
```

**Error Handling:**
- All errors displayed in UI with user-friendly messages
- OAuth errors include guidance (e.g., "close previous windows")
- Project not found errors suggest verifying project ID and permissions

## Common UI Patterns

### Settings Tab Layouts

**For data-heavy settings tabs** (logs, tables, lists with filtering), use the **Full-Height Pattern**:

```tsx
// ✅ RECOMMENDED: Full-height with sticky header (LogsSettingsTab pattern)
<div className="h-full w-full flex flex-col" style={{ overflow: 'hidden' }}>
  <header className="shrink-0 z-10 backdrop-blur relative" style={{ /* ... */ }}>
    {/* Icon badge + title + stats */}
  </header>
  <main className="flex-1 overflow-y-auto">
    {/* Scrollable content */}
  </main>
</div>
```

**For simple settings tabs** (forms, basic lists), use the **Simple Pattern**:

```tsx
// ✅ SIMPLE: Basic spacing layout (AppearanceTab, ConnectionsTab pattern)
<div className="space-y-4">
  <h3>Title</h3>
  {/* Content */}
</div>
```

**See**: Advanced Layout Patterns section for complete implementation details and comparison.

### Empty States

Use the `EmptyState` component for empty/initial states:

```tsx
import { Button } from './ui';

<EmptyState
  icon={<svg>...</svg>}
  title="No Resources"
  description="Connect to a project to see topics and subscriptions."
  action={{
    label: 'Connect',
    onClick: () => handleConnect()
  }}
/>

// EmptyState internally uses Button component from './ui'
```

### Loading States

```tsx
{loading ? (
  <div className="flex items-center justify-center p-8">
    <div style={{ color: 'var(--color-text-muted)' }}>Loading...</div>
  </div>
) : (
  // Content
)}
```

### Error Display

**CRITICAL RULE**: All user-facing errors MUST be displayed in the UI. Never rely solely on `console.error` for errors that affect user actions.

**When to Display Errors in UI:**

* ✅ **ALWAYS display** errors from async operations triggered by user actions (button clicks, form submissions)
* ✅ **ALWAYS display** errors from event handlers that perform user-visible operations
* ✅ **ALWAYS display** errors that prevent operations from completing
* ✅ **ALWAYS display** errors in notification components (e.g., upgrade notifications, connection dialogs)
* ⚠️ **May skip UI display** for background operations that fail silently (e.g., periodic checks that don't block user)
* ⚠️ **May skip UI display** for non-critical errors that are logged for debugging only

**Common Mistake - Missing Error Display:**

```tsx
// ❌ WRONG: Only logging to console
const handleDismiss = async () => {
  try {
    await DismissUpgradeNotification(version);
  } catch (error) {
    console.error('Failed to dismiss:', error); // User never sees this!
  }
};

// ✅ CORRECT: Display error in UI
const [error, setError] = useState<string>('');

const handleDismiss = async () => {
  setError('');
  try {
    await DismissUpgradeNotification(version);
    setError(''); // Clear on success
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    setError('Failed to dismiss notification: ' + errorMessage);
    // Keep notification visible on error so user can see the error
  }
};

// Display error in JSX
{error && (
  <div style={{
    backgroundColor: 'var(--color-error-bg)',
    borderColor: 'var(--color-error-border)',
    color: 'var(--color-error)',
  }} className="p-2 border rounded text-xs mb-2">
    {error}
  </div>
)}
```

**Basic Error Display:**
```tsx
// ✅ PREFERRED: Use shadcn/ui Alert component
import { Alert, AlertDescription } from './ui';

{error && (
  <Alert variant="destructive" className="mb-4">
    <AlertDescription>{error}</AlertDescription>
  </Alert>
)}

// Alternative: Custom error div (if Alert doesn't fit)
{error && (
  <div
    style={{
      backgroundColor: 'var(--color-error-bg)',
      borderColor: 'var(--color-error-border)',
      color: 'var(--color-error)',
    }}
    className="border rounded-md p-3 mb-4"
  >
    {error}
  </div>
)}
```

**Error Banner Pattern (for prominent errors):**
```tsx
{error && (
  <div
    style={{
      backgroundColor: 'var(--color-error-bg)',
      borderBottomColor: 'color-mix(in srgb, var(--color-error-border) 50%, transparent)',
    }}
    className="p-4 border-b"
  >
    <div className="flex items-start gap-3">
      <svg
        style={{ color: 'var(--color-error)' }}
        className="w-5 h-5 shrink-0 mt-0.5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <div className="flex-1">
        <h4
          style={{ color: 'var(--color-error)' }}
          className="text-sm font-semibold mb-1"
        >
          Error Title
        </h4>
        <p
          style={{ color: 'var(--color-error)' }}
          className="text-sm opacity-90"
        >
          {error}
        </p>
      </div>
    </div>
  </div>
)}
```

**Error State Management Pattern:**
```tsx
const [error, setError] = useState<string>('');

const handleAction = async () => {
  setError(''); // Clear previous errors
  try {
    await someAsyncOperation();
    setError(''); // Clear on success
  } catch (err) {
    // Convert to user-friendly message
    const errorMessage = err instanceof Error ? err.message : String(err);
    let friendlyError = errorMessage;

    // Add context for common error types
    if (errorMessage.includes('Permission denied')) {
      friendlyError = 'Permission denied: You need the "pubsub.subscriptions.create" permission. Please contact your administrator.';
    } else if (errorMessage.includes('NotFound')) {
      friendlyError = 'Resource not found: The resource may not exist or you may not have access to it.';
    }

    setError(friendlyError);
  }
};
```

**Error Handling in Event Listeners:**
```tsx
// When listening to Wails events that might fail
useEffect(() => {
  const unsubscribeError = EventsOn('monitor:error', (data: { error: string }) => {
    setError(data.error); // Display in UI
  });

  return () => unsubscribeError();
}, []);
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Only logging to console
try {
  await someOperation();
} catch (err) {
  console.error('Failed:', err); // User never sees this!
}

// ❌ WRONG: Not converting technical errors
catch (err) {
  setError(err.toString()); // Shows raw API error
}

// ❌ WRONG: Missing error display in notification components
const handleAction = async () => {
  try {
    await SomeWailsMethod();
  } catch (error) {
    console.error('Failed:', error); // User never sees this in notification!
  }
};

// ✅ CORRECT: Display in UI with user-friendly message
const [error, setError] = useState<string>('');

try {
  await someOperation();
  setError(''); // Clear on success
} catch (err) {
  const errorMessage = err instanceof Error ? err.message : String(err);
  setError('Failed: ' + errorMessage); // User sees this in UI
}

// ✅ CORRECT: Display error in notification/component UI
{error && (
  <div style={{
    backgroundColor: 'var(--color-error-bg)',
    borderColor: 'var(--color-error-border)',
    color: 'var(--color-error)',
  }} className="p-2 border rounded text-xs">
    {error}
  </div>
)}
```

### Tabs (Radix UI)

The codebase uses Radix UI Tabs in `SubscriptionDetails.tsx`:

```tsx
import * as Tabs from '@radix-ui/react-tabs';

// Use CSS for active state styling
<style>{`
  [data-state="active"] {
    color: var(--color-text-primary) !important;
    border-bottom-color: var(--color-accent-primary) !important;
  }
`}</style>

<Tabs.Root value={activeTab} onValueChange={setActiveTab} className="flex flex-col flex-1">
  <Tabs.List
    style={{ borderBottomColor: 'var(--color-border-primary)' }}
    className="flex gap-2 border-b"
  >
    <Tabs.Trigger
      value="metadata"
      style={{
        color: 'var(--color-text-muted)',
        borderBottomWidth: '2px',
        borderBottomStyle: 'solid',
        borderBottomColor: 'transparent',
      }}
      className="px-4 py-2 text-sm font-medium transition-colors hover:opacity-80"
    >
      Metadata
    </Tabs.Trigger>
    <Tabs.Trigger value="monitor" style={{ ... }}>
      Monitor
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="metadata" className="flex-1 overflow-auto">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Advanced Layout Patterns

### Full-Height Settings Tab Pattern

**Use this pattern for settings tabs that need to fill all available space with a scrollable content area and sticky header.**

**Key Characteristics:**
- Container uses `flex flex-col` with `overflow: hidden`
- Sticky header with backdrop blur effect
- Scrollable content area that fills remaining space
- Professional header design with icon badge, title, and stats

**Example (LogsSettingsTab):**
```tsx
export function LogsSettingsTab() {
  return (
    <div
      className="h-full w-full flex flex-col"
      style={{ backgroundColor: 'var(--color-bg-primary)', overflow: 'hidden' }}
    >
      {/* Sticky Header */}
      <header
        className="shrink-0 z-10 backdrop-blur relative"
        style={{
          borderBottomColor: 'var(--color-border-primary)',
          borderBottomWidth: '1px',
          borderBottomStyle: 'solid',
          backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 95%, transparent)',
          overflow: 'visible', // Allow dropdowns to overflow
        }}
      >
        <div className="px-6 py-3" style={{ overflow: 'visible' }}>
          {/* Header content */}
        </div>
      </header>

      {/* Scrollable Content */}
      <main className="flex-1 flex flex-col overflow-hidden p-6">
        <div className="flex-1 overflow-y-auto space-y-2 min-h-0">
          {/* Scrollable content */}
        </div>
      </main>
    </div>
  );
}
```

**Key Points:**
- **Container**: `h-full w-full flex flex-col` with `overflow: hidden` (prevents double scrollbars)
- **Header**: `shrink-0` (doesn't shrink), `backdrop-blur` (blur effect), `overflow: visible` (allows dropdowns)
- **Content**: `flex-1` (fills space), `overflow-y-auto` (scrolls internally), `min-h-0` (allows shrinking)
- **Backdrop blur background**: `color-mix(in srgb, var(--color-bg-primary) 95%, transparent)` for semi-transparent effect

### Sticky Header with Icon Badge Pattern

**Professional header design with icon, title, stats, and actions.**

**Example:**
```tsx
<header className="shrink-0 z-10 backdrop-blur relative" style={{ /* ... */ }}>
  <div className="px-6 py-3">
    {/* Title and Stats Row */}
    <div className="flex items-center justify-between mb-3">
      <div className="flex items-center gap-3">
        {/* Icon Badge */}
        <div
          className="h-6 w-6 rounded flex items-center justify-center"
          style={{ backgroundColor: 'var(--color-accent-primary)' }}
        >
          <FileText className="h-4 w-4" style={{ color: 'white' }} />
        </div>
        {/* Title */}
        <h1 className="text-xl font-semibold" style={{ color: 'var(--color-text-primary)' }}>
          Logs Explorer
        </h1>
        {/* Separator */}
        <span className="text-sm" style={{ color: 'var(--color-text-secondary)' }}>|</span>
        {/* Stats */}
        <span className="text-sm" style={{ color: 'var(--color-text-secondary)' }}>
          {total} entries
        </span>
      </div>
      {/* Action Button */}
      <Button variant="ghost" size="sm" onClick={handleAction}>
        Refresh
      </Button>
    </div>
    {/* Additional header content (filters, stats, etc.) */}
  </div>
</header>
```

**Key Points:**
- **Icon badge**: Small rounded square with accent background, white icon
- **Title**: Large, semibold text
- **Separator**: Vertical bar (`|`) with secondary text color
- **Stats**: Secondary text color, shows summary information
- **Actions**: Right-aligned buttons (ghost variant for less prominence)

### Compact Filter Row Pattern

**Organize multiple filters in a single compact row with proper spacing and overflow handling.**

**Example:**
```tsx
<div className="flex items-center gap-3 flex-wrap relative" style={{ overflow: 'visible' }}>
  {/* Search Input */}
  <div className="relative flex-1 min-w-[200px] max-w-sm">
    <Search className="absolute left-2 top-1/2 -translate-y-1/2 h-3.5 w-3.5" />
    <Input
      placeholder="Search..."
      className="pl-8 h-8 text-sm"
      style={{
        backgroundColor: 'var(--color-bg-secondary)',
        borderColor: 'var(--color-border-primary)',
      }}
    />
  </div>

  {/* Filter Dropdowns */}
  <LogLevelFilter {...props} />
  <LogDateRangeFilter {...props} />

  {/* Additional Controls */}
  <div className="flex items-center gap-2 ml-auto">
    {/* Controls */}
  </div>
</div>
```

**Key Points:**
- **Container**: `flex items-center gap-3 flex-wrap` with `overflow: visible`
- **Search**: `flex-1 min-w-[200px] max-w-sm` for responsive sizing
- **Filters**: Fixed-width dropdowns
- **Controls**: `ml-auto` to push to the right
- **Overflow**: `overflow: visible` on container allows dropdowns to overflow

### Settings Tab Design Comparison

**What Makes LogsSettingsTab Look Professional:**

The LogsSettingsTab demonstrates several design patterns that make it stand out compared to simpler settings tabs:

**1. Full-Height Layout vs. Simple Spacing**
- **LogsSettingsTab**: Uses flexbox to fill all available space with scrollable content
- **Other tabs**: Use simple `space-y-4` which doesn't utilize full height

**2. Sticky Header with Backdrop Blur**
- **LogsSettingsTab**: Header stays visible while scrolling with modern blur effect
- **Other tabs**: Headers scroll away, less professional appearance

**3. Icon Badge + Title Pattern**
- **LogsSettingsTab**: Icon in accent-colored badge, title, separator, stats all in one row
- **Other tabs**: Simple `h3` heading without visual hierarchy

**4. Stats Display**
- **LogsSettingsTab**: Prominently shows log level counts (DEBUG: 0, INFO: 4, etc.)
- **Other tabs**: No summary statistics

**5. Compact Filter Organization**
- **LogsSettingsTab**: All filters in one organized row with proper spacing
- **Other tabs**: Filters (if any) are scattered or in separate sections

**6. Visual Hierarchy**
- **LogsSettingsTab**: Clear separation between header (sticky) and content (scrollable)
- **Other tabs**: Flat structure without clear visual separation

**When to Use Full-Height Pattern:**

✅ **Use full-height pattern when:**
- Tab has scrollable content (lists, tables, logs)
- Tab needs filters/search that should stay visible
- Tab benefits from professional header design
- Tab needs to fill all available space

❌ **Use simple pattern when:**
- Tab has minimal content (simple forms, settings)
- Content fits in viewport without scrolling
- Simple list or grid layout is sufficient

**Migration Guide:**

To upgrade a simple settings tab to the full-height pattern:

1. **Change container** from `space-y-4` to flexbox layout
2. **Add sticky header** with backdrop blur
3. **Add icon badge** to header (optional but recommended)
4. **Add stats display** if applicable (optional)
5. **Organize filters** in compact row (if applicable)
6. **Make content scrollable** with `flex-1 overflow-y-auto`

## Best Practices

1. **Accessibility**
   - Use semantic HTML
   - Add ARIA labels where needed
   - Ensure keyboard navigation works
   - Radix UI components handle accessibility automatically

2. **Performance**
   - Use `useMemo` for expensive computations
   - Use `useCallback` for stable function references
   - Avoid unnecessary re-renders

3. **Code Organization**
   - One component per file
   - Keep components focused and small
   - Extract reusable logic into custom hooks

4. **Styling**
   - **PRIORITIZE semantic CSS variables** (`var(--color-*)`) via inline styles or custom CSS classes
   - Use Tailwind utilities only as fallback when semantic styling isn't practical
   - Use consistent spacing scale (Tailwind spacing utilities are fine)
   - All colors must use theme variables for theme compatibility

5. **Error Handling**
   - **CRITICAL**: ALL user-facing errors MUST be displayed in the UI, not just logged to console
   - Always handle async errors with try-catch
   - Display user-friendly error messages with actionable guidance
   - Clear errors on new actions or when operations succeed
   - Use error state management (see Error State Management section below)
   - Convert technical errors to user-friendly messages (e.g., permission errors should explain what permission is needed)
   - Never use `console.error` as the only error handling - always show errors to users

6. **Type Safety**
   - Type all props with interfaces
   - Use TypeScript strict mode
   - Avoid `any` when possible (use `as` for Wails types if needed)

7. **Layout Patterns**
   - **Full-height tabs**: Use flexbox with sticky headers for professional-looking settings tabs
   - **Sticky headers**: Use `backdrop-blur` and semi-transparent backgrounds for modern look
   - **Icon badges**: Use accent-colored badges with white icons for visual hierarchy
   - **Compact filters**: Organize filters in single row with proper overflow handling

## Development Workflow

### Running the Dev Server

```bash
# From project root
wails dev

# Or standalone frontend (for UI-only development)
cd frontend
npm run dev
```

### Hot Reload

- Wails dev mode supports hot reload for both Go and React
- Frontend changes auto-reload in the desktop window
- Go changes require app restart

### Debugging

- Use browser DevTools (available in Wails dev mode)
- Console logs appear in terminal and DevTools
- React DevTools extension works in dev mode

## Common Gotchas

1. **Wails Bindings**: Never edit files in `wailsjs/` - they're auto-generated
2. **Async Operations**: Always handle loading and error states
3. **Event Cleanup**: Unsubscribe from Wails events in `useEffect` cleanup
4. **Type Assertions**: Wails return types may need `as` assertions for TypeScript
5. **Dark Theme**: All components should work with dark theme (slate colors)
6. **Async State Race Conditions**:
   - **ALWAYS await async operations** that update state
   - **ALWAYS clear dependent state** before starting connection/profile switches
   - **ALWAYS verify connection** before loading resources after a switch
   - Never call async functions without `await` when they update state
7. **Connection Switching**: When switching profiles or connections:
   - Clear resources immediately (topics, subscriptions, selections)
   - Wait for backend switch to complete
   - Verify new connection status
   - Only then load new resources
   - Clear resources on any error
8. **useEffect Dependencies**: Avoid including frequently changing state (like `selectedResource`) in dependency arrays that trigger expensive operations:
   - Use `useRef` to track values needed in event listeners without causing re-renders
   - Split initialization effects from event listener effects
   - Only include dependencies that should trigger the effect
9. **Wails Type Conversion**: When passing complex objects to Wails methods:
   - Use `main.TypeName.createFrom(plainObject)` to convert plain objects to Wails-generated class instances
   - Wails-generated types have `convertValues` method - plain interfaces don't
   - Import Wails models: `import { main } from "../wailsjs/go/models"`

   **Example:**
   ```tsx
   import { main } from "../wailsjs/go/models";
   import { UpdateSubscription } from "../wailsjs/go/main/App";

   // Plain TypeScript interface
   const params = {
     ackDeadline: 30,
     retentionDuration: "7d",
     filter: "attributes.eventType = 'user.signup'"
   };

   // Convert to Wails-generated class instance
   const wailsParams = main.SubscriptionUpdateParams.createFrom(params);

   // Now can be passed to Wails method
   await UpdateSubscription(subID, wailsParams);
   ```

## CRUD Dialog Patterns

### Create/Edit Dialog Structure

```tsx
interface ResourceDialogProps {
  open: boolean;
  mode: 'create' | 'edit';
  resource?: Resource; // For edit mode
  onClose: () => void;
  onCreate?: (params: CreateParams) => Promise<void>;
  onUpdate?: (id: string, params: UpdateParams) => Promise<void>;
  error?: string;
}

export default function ResourceDialog({
  open,
  mode,
  resource,
  onClose,
  onCreate,
  onUpdate,
  error: externalError,
}: ResourceDialogProps) {
  const [formData, setFormData] = useState({});
  const [error, setError] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  // Populate form when editing
  useEffect(() => {
    if (mode === 'edit' && resource) {
      setFormData({ /* populate from resource */ });
    } else {
      setFormData({ /* reset for create */ });
    }
    setError('');
  }, [mode, resource, open]);

  const handleSave = async () => {
    setError('');
    // Validate
    if (!isValid()) {
      setError('Validation error');
      return;
    }

    setIsSaving(true);
    try {
      if (mode === 'create' && onCreate) {
        await onCreate(formData);
      } else if (mode === 'edit' && onUpdate && resource) {
        await onUpdate(resource.id, formData);
      }
      onClose();
    } catch (e: any) {
      setError(e.toString());
    } finally {
      setIsSaving(false);
    }
  };

  if (!open) return null;

  return (
    <div
      style={{
        backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 50%, transparent)',
      }}
      className="fixed inset-0 flex items-center justify-center z-50"
    >
      <div
        style={{
          backgroundColor: 'var(--color-bg-secondary)',
          borderColor: 'var(--color-border-primary)',
          color: 'var(--color-text-primary)',
        }}
        className="border rounded-lg p-6 max-w-md w-full mx-4"
      >
        <h3 className="text-lg font-semibold mb-4">
          {mode === 'create' ? 'Create Resource' : 'Edit Resource'}
        </h3>
        {/* Form fields */}
        {(error || externalError) && (
          <Alert variant="destructive">
            <AlertDescription>{error || externalError}</AlertDescription>
          </Alert>
        )}
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isSaving}>Cancel</Button>
          <Button onClick={handleSave} loading={isSaving}>
            {mode === 'create' ? 'Create' : 'Save'}
          </Button>
        </DialogFooter>
      </div>
    </div>
  );
}
```

### Delete Confirmation Dialog Pattern

```tsx
interface DeleteConfirmDialogProps {
  open: boolean;
  resourceType: 'topic' | 'subscription';
  resourceName: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export default function DeleteConfirmDialog({
  open,
  resourceType,
  resourceName,
  onConfirm,
  onCancel,
}: DeleteConfirmDialogProps) {
  if (!open) return null;

  const displayName = resourceName.split('/').pop() || resourceName;

  return (
    <div
      style={{
        backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 50%, transparent)',
      }}
      className="fixed inset-0 flex items-center justify-center z-50"
    >
      <div
        style={{
          backgroundColor: 'var(--color-bg-secondary)',
          borderColor: 'var(--color-border-primary)',
          color: 'var(--color-text-primary)',
        }}
        className="border rounded-lg p-6 max-w-md w-full mx-4"
      >
        <h3
          style={{ color: 'var(--color-error)' }}
          className="text-lg font-semibold mb-4"
        >
          Delete {resourceType === 'topic' ? 'Topic' : 'Subscription'}
        </h3>
        <p
          style={{ color: 'var(--color-text-secondary)' }}
          className="mb-2"
        >
          Are you sure you want to delete this {resourceType}?
        </p>
        <code
          style={{
            backgroundColor: 'var(--color-bg-code)',
            color: 'var(--color-text-primary)',
          }}
          className="block rounded p-3 text-sm mb-3 break-all"
        >
          {displayName}
        </code>
        <p
          style={{ color: 'var(--color-error)' }}
          className="text-sm mb-4"
        >
          This action cannot be undone.
        </p>
        <DialogFooter>
          <Button variant="outline" onClick={onCancel}>Cancel</Button>
          <Button variant="destructive" onClick={onConfirm}>
            Delete
          </Button>
        </DialogFooter>
      </div>
    </div>
  );
}
```

### Event-Driven UI Updates

Use Wails events to refresh UI after CRUD operations:

```tsx
useEffect(() => {
  // Set up event listeners once on mount
  const unsubscribeTopicCreated = EventsOn('topic:created', () => {
    loadResources(); // Refresh list
  });

  const unsubscribeTopicDeleted = EventsOn('topic:deleted', () => {
    loadResources();
    // Clear selection if deleted resource was selected
    if (selectedResourceRef.current?.type === 'topic') {
      setSelectedResource(null);
    }
  });

  return () => {
    unsubscribeTopicCreated();
    unsubscribeTopicDeleted();
  };
}, []); // Empty dependency array - only set up once

// Use ref to track selectedResource without causing re-renders
const selectedResourceRef = useRef(selectedResource);
useEffect(() => {
  selectedResourceRef.current = selectedResource;
}, [selectedResource]);
```

**Key Pattern:**
- Set up event listeners once in `useEffect` with empty dependency array
- Use `useRef` to track state values needed in event callbacks
- Update ref in separate `useEffect` when state changes
- This prevents unnecessary re-initialization of event listeners

## shadcn/ui Wrapper Decision Guide

**When to Create a Wrapper:**

✅ **Create a wrapper when:**
- Component needs app-specific features (e.g., `loading` prop for Button, `error` prop for Input)
- Component needs custom variants not in shadcn (e.g., `success` and `warning` for Alert/Badge)
- Component needs complex theme integration that CSS variables alone can't handle
- Component needs to preserve original shadcn component for easy updates

❌ **Don't create a wrapper when:**
- CSS variables are already mapped in `themes.css` and work correctly
- Component works perfectly with native shadcn styling
- No additional features or customizations needed
- Wrapper would only duplicate existing functionality

**Wrapper Pattern:**
```tsx
// Wrapper preserves original component
import { Button as ShadcnButton } from "./button"

export interface ButtonProps extends ShadcnButtonProps {
  loading?: boolean // Add custom feature
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ loading, ...props }, ref) => {
    return (
      <ShadcnButton ref={ref} disabled={loading || props.disabled} {...props}>
        {loading && <Spinner />}
        {props.children}
      </ShadcnButton>
    )
  }
)
```

**Benefits of Wrapper Pattern:**
- Original shadcn components remain untouched (easier to update)
- Custom features isolated in wrappers
- Can switch between wrapper and native as needed
- Theme compatibility ensured via CSS variables or wrapper styling

## Resources

- [Tailwind CSS v4 Docs](https://tailwindcss.com/docs)
- [shadcn/ui Docs](https://ui.shadcn.com/)
- [Radix UI Docs](https://www.radix-ui.com/)
- [Wails v2 Docs](https://wails.io/docs/v2/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)

---

**Last Updated:** 2026-01-10
