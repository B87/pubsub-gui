---
description: UI Development Guide for Pub/Sub GUI
alwaysApply: false
---
# UI Development Guide for Pub/Sub GUI

This guide covers UI development patterns, conventions, and best practices for the Pub/Sub GUI desktop application.

## Tech Stack

- **Framework**: React 18 with TypeScript
- **Styling**: Tailwind CSS v4 (using `@tailwindcss/postcss`)
- **UI Components**: Radix UI (accessible, unstyled primitives)
- **Build Tool**: Vite 3
- **Desktop Framework**: Wails v2 (Go backend + React frontend)

## Project Structure

```
frontend/src/
├── components/          # React components
│   ├── Layout.tsx      # Main layout wrapper (sidebar + main)
│   ├── Sidebar.tsx     # Resource navigation sidebar
│   ├── TopicDetails.tsx
│   ├── SubscriptionDetails.tsx
│   └── ...
├── types/              # TypeScript type definitions
│   └── index.ts
├── wailsjs/           # Auto-generated Wails bindings (DO NOT EDIT)
│   └── go/main/App.js
├── App.tsx            # Root component
├── main.tsx           # React entry point
└── style.css          # Global styles + Tailwind imports
```

## Component Patterns

### Component Structure

```typescript
import { useState, useEffect } from 'react';
import type { Topic } from '../types';
import { SomeWailsMethod } from '../wailsjs/go/main/App';

interface ComponentProps {
  topic: Topic;
  onAction?: () => void;
}

export default function Component({ topic, onAction }: ComponentProps) {
  const [state, setState] = useState<string>('');

  useEffect(() => {
    // Side effects
  }, [topic]);

  return (
    <div className="...">
      {/* Component JSX */}
    </div>
  );
}
```

### Component Creation Checklist

**CRITICAL**: Before creating or modifying any component, ensure:

**Theme System Compliance:**
- [ ] All colors use semantic CSS variables (`var(--color-*)`) via inline styles or custom CSS classes
- [ ] NO hardcoded colors (`style={{ color: '#fff' }}` or `bg-[#...]`)
- [ ] Tailwind classes only used as fallback when semantic styling isn't practical
- [ ] Opacity variants use `color-mix()` with CSS variables (e.g., `color-mix(in srgb, var(--color-bg-primary) 30%, transparent)`)
- [ ] All components tested with all 5 themes to ensure proper appearance

**Testing:**
- [ ] Component tested visually in Dark theme (default)
- [ ] Component tested in Light theme (check contrast)
- [ ] Component tested in Dracula theme (purple accent)
- [ ] Component tested in Monokai theme (cyan accent)
- [ ] Component works with "Auto" theme (system preference)

**Common Issues to Avoid:**
- Border/hover colors not adapting to theme
- Text contrast too low in Light theme
- Status colors (success/error/warning) hardcoded
- Modal/dialog backgrounds not using theme variables
- Accent colors hardcoded to blue (should use theme accent)

### Naming Conventions

- **Components**: PascalCase, descriptive names (e.g., `TopicDetails`, `ConnectionDialog`)
- **Files**: Match component name (e.g., `TopicDetails.tsx`)
- **Props interfaces**: `ComponentNameProps` (e.g., `TopicDetailsProps`)
- **Types**: PascalCase, exported from `types/index.ts`

## Styling Guidelines

### Theme System

**CRITICAL**: This application uses a comprehensive theme system with 5 themes (Auto, Dark, Light, Dracula, Monokai) and 3 font sizes. **ALL components MUST use the theme system.**

**Core Requirements:**
1. **NEVER use hardcoded colors** - Always use semantic CSS variables
2. **PRIORITIZE semantic style format** - Use CSS custom properties directly via inline styles or custom CSS classes
3. **Tailwind classes are fallback** - Only use Tailwind utility classes when semantic styling isn't practical
4. **Test with multiple themes** - Components should work correctly in all 5 themes
5. **Reference theme documentation** - See `.cursor/rules/theme-system.mdc` for complete details

**Theme System Architecture:**
- **CSS Variables**: All colors defined as CSS custom properties in `frontend/src/themes.css`
- **Semantic Tokens**: Use semantic variable names (e.g., `--color-bg-primary`, `--color-text-primary`)
- **Runtime Switching**: Themes can be changed without reloading the app
- **System Integration**: "Auto" theme respects OS dark/light mode preference
- **Backward Compatibility**: Tailwind classes are mapped to theme variables for existing code

**Semantic CSS Variables (PREFERRED):**

```typescript
// ✅ PREFERRED: Use semantic CSS variables directly
<div style={{ backgroundColor: 'var(--color-bg-primary)' }}>...</div>
<div style={{ color: 'var(--color-text-primary)' }}>...</div>
<div style={{ borderColor: 'var(--color-border-primary)' }}>...</div>

// Or define custom CSS classes in component stylesheet:
// .card { background-color: var(--color-bg-secondary); }
// .card-text { color: var(--color-text-primary); }
```

**Available Semantic Tokens:**

```css
/* Backgrounds */
--color-bg-primary        /* Main app background */
--color-bg-secondary      /* Sidebar, cards */
--color-bg-tertiary       /* Inputs, buttons */
--color-bg-hover          /* Hover states */
--color-bg-input          /* Input field backgrounds */
--color-bg-code           /* Code block backgrounds */

/* Text */
--color-text-primary      /* Primary text */
--color-text-secondary    /* Secondary text */
--color-text-tertiary     /* Tertiary text */
--color-text-muted        /* Muted/placeholder text */
--color-text-disabled     /* Disabled text */

/* Borders */
--color-border-primary    /* Primary borders */
--color-border-secondary   /* Secondary borders */

/* Accents */
--color-accent-primary    /* Primary actions (buttons, links) */
--color-accent-hover      /* Accent hover state */
--color-accent-active     /* Accent active state */
--color-accent-light      /* Light accent variant */
--color-accent-dark       /* Dark accent variant */

/* Status Colors */
--color-success           /* Success state */
--color-success-hover     /* Success hover */
--color-success-bg        /* Success background */
--color-success-border    /* Success border */

--color-error             /* Error state */
--color-error-hover       /* Error hover */
--color-error-bg          /* Error background */
--color-error-border      /* Error border */

--color-warning           /* Warning state */
--color-warning-hover     /* Warning hover */
--color-warning-bg        /* Warning background */
--color-warning-border    /* Warning border */

/* Special Colors */
--color-purple-bg         /* Purple background */
--color-purple-text       /* Purple text */
--color-purple-border     /* Purple border */
--color-orange            /* Orange color */
```

**Tailwind Classes (FALLBACK - for backward compatibility):**

Tailwind utility classes are available as a fallback for existing code, but **new code should prefer semantic styling**:

```typescript
// ⚠️ FALLBACK: Use Tailwind classes only when semantic styling isn't practical
// These are mapped to theme variables for backward compatibility
<div className="bg-slate-800">...</div>  // Maps to var(--color-bg-secondary)
<div className="text-slate-100">...</div> // Maps to var(--color-text-primary)
```

**Styling Patterns:**

```tsx
// ✅ PREFERRED: Semantic inline styles
<div style={{
  backgroundColor: 'var(--color-bg-secondary)',
  color: 'var(--color-text-primary)',
  borderColor: 'var(--color-border-primary)'
}}>
  Content
</div>

// ✅ PREFERRED: Custom CSS classes with semantic variables
// In component stylesheet or CSS module:
.card {
  background-color: var(--color-bg-secondary);
  color: var(--color-text-primary);
  border: 1px solid var(--color-border-primary);
}

// ⚠️ FALLBACK: Tailwind classes (use sparingly)
<div className="bg-slate-800 text-slate-100 border border-slate-700">
  Content
</div>
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Hardcoded colors (breaks theme system)
<div style={{ backgroundColor: '#1e293b' }}>...</div>
<div className="bg-[#1e293b]">...</div>

// ❌ WRONG: Using un-mapped Tailwind classes
<div className="bg-slate-950">...</div>  // Not mapped to theme variables

// ⚠️ ACCEPTABLE BUT NOT PREFERRED: Tailwind classes
<div className="bg-slate-800">...</div>  // Works but not semantic

// ✅ PREFERRED: Semantic CSS variables
<div style={{ backgroundColor: 'var(--color-bg-secondary)' }}>...</div>
```

### Tailwind CSS v4 Usage

This project uses **Tailwind CSS v4** with the new `@import "tailwindcss"` syntax.

**Key Principles:**
1. **PRIORITIZE semantic CSS variables** - Use `var(--color-*)` via inline styles or custom CSS classes
2. **Tailwind for layout/spacing** - Use Tailwind utilities for spacing (p-4, m-2, gap-3), layout (flex, grid), and sizing (w-full, h-screen)
3. **Tailwind classes as fallback** - Only use Tailwind color classes when semantic styling isn't practical
4. **Theme system compliance** - All color styling must use theme variables for compatibility with all 5 themes
5. **Consistent spacing**: Use Tailwind's spacing scale (p-4, m-2, gap-3, etc.)
6. **Responsive design**: Not required for desktop app, but maintain consistent sizing

### Common Patterns

**Buttons:**
```tsx
// ✅ PREFERRED: Primary button with semantic styling
<button
  style={{
    backgroundColor: 'var(--color-accent-primary)',
    color: 'white',
  }}
  className="px-4 py-2 rounded-md transition-colors hover:opacity-90"
  onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--color-accent-hover)'}
  onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'var(--color-accent-primary)'}
>
  Submit
</button>

// ✅ PREFERRED: Secondary button with semantic styling
<button
  style={{
    backgroundColor: 'var(--color-bg-tertiary)',
    color: 'var(--color-text-primary)',
  }}
  className="px-4 py-2 rounded-md transition-colors"
  onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--color-bg-hover)'}
  onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'var(--color-bg-tertiary)'}
>
  Cancel
</button>

// ✅ PREFERRED: Text button with semantic styling
<button
  style={{ color: 'var(--color-text-muted)' }}
  className="transition-colors"
  onMouseEnter={(e) => e.currentTarget.style.color = 'var(--color-text-secondary)'}
  onMouseLeave={(e) => e.currentTarget.style.color = 'var(--color-text-muted)'}
>
  Disconnect
</button>

// ⚠️ FALLBACK: Using Tailwind classes (acceptable but not preferred)
<button className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors">
  Submit
</button>
```

**Input Fields:**
```tsx
// ✅ PREFERRED: Input with semantic styling
<input
  type="text"
  value={value}
  onChange={(e) => setValue(e.target.value)}
  style={{
    backgroundColor: 'var(--color-bg-input)',
    color: 'var(--color-text-primary)',
    borderColor: 'var(--color-border-primary)',
  }}
  className="w-full px-3 py-2 rounded-md text-sm transition-colors focus:outline-none focus:ring-2"
  onFocus={(e) => e.currentTarget.style.borderColor = 'var(--color-accent-primary)'}
  onBlur={(e) => e.currentTarget.style.borderColor = 'var(--color-border-primary)'}
  placeholder="Enter text..."
/>

// Style placeholder text via CSS:
// input::placeholder { color: var(--color-text-muted); }
```

**Cards/Panels:**
```tsx
// ✅ PREFERRED: Card with semantic styling
<div
  style={{
    backgroundColor: 'var(--color-bg-secondary)',
    borderColor: 'var(--color-border-primary)',
  }}
  className="border rounded-lg p-4"
>
  {/* Card content */}
</div>
```

**Loading States:**
```tsx
// ✅ PREFERRED: Button with semantic disabled state
<button
  disabled={loading}
  style={{
    backgroundColor: loading ? 'var(--color-bg-tertiary)' : 'var(--color-accent-primary)',
    color: 'white',
    opacity: loading ? 0.5 : 1,
    cursor: loading ? 'not-allowed' : 'pointer',
  }}
  className="px-4 py-2 rounded-md transition-all"
>
  {loading ? 'Loading...' : 'Submit'}
</button>
```

## Radix UI Integration

Radix UI provides accessible, unstyled primitives. **PREFER semantic CSS variables** for styling, with Tailwind classes as fallback.

**Radix Components Available:**
- `@radix-ui/react-tabs` - ✅ **Used** in `SubscriptionDetails.tsx` for tabbed interfaces
- `@radix-ui/react-dialog` - Available but not currently used (codebase uses custom modals)
- `@radix-ui/react-dropdown-menu` - Available for dropdown menus
- `@radix-ui/react-select` - Available for select dropdowns
- `@radix-ui/react-label` - Available for form labels
- `@radix-ui/react-separator` - Available for visual separators

**Note:** The codebase currently uses custom div-based modals instead of Radix Dialog. Radix Dialog is available if you want to use it for better accessibility features.

**Example - Custom Modal (PREFERRED Pattern):**
```tsx
interface DialogProps {
  open: boolean;
  onClose: () => void;
}

export default function CustomDialog({ open, onClose }: DialogProps) {
  if (!open) return null;

  return (
    <div
      style={{
        backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 50%, transparent)',
      }}
      className="fixed inset-0 flex items-center justify-center z-50"
    >
      <div
        style={{
          backgroundColor: 'var(--color-bg-secondary)',
          borderColor: 'var(--color-border-primary)',
          color: 'var(--color-text-primary)',
        }}
        className="border rounded-lg p-6 max-w-md w-full mx-4"
      >
        <h3 className="text-lg font-semibold mb-4">Title</h3>
        {/* Content */}
        <div className="flex gap-3 justify-end mt-4">
          <button onClick={onClose}>Cancel</button>
          <button onClick={handleSave}>Save</button>
        </div>
      </div>
    </div>
  );
}
```

**Example - Radix Tabs (PREFERRED Pattern):**
```tsx
import * as Tabs from '@radix-ui/react-tabs';

// Use CSS for active state styling
<style>{`
  [data-state="active"] {
    color: var(--color-text-primary) !important;
    border-bottom-color: var(--color-accent-primary) !important;
  }
`}</style>

<Tabs.Root value={activeTab} onValueChange={setActiveTab}>
  <Tabs.List
    style={{ borderBottomColor: 'var(--color-border-primary)' }}
    className="flex border-b"
  >
    <Tabs.Trigger
      value="tab1"
      style={{
        color: 'var(--color-text-secondary)',
        borderBottomWidth: '2px',
        borderBottomStyle: 'solid',
        borderBottomColor: 'transparent',
      }}
      className="px-4 py-2 transition-colors"
    >
      Tab 1
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="tab1">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Wails Integration

### Wails Binding Generation

**Important:** Wails TypeScript bindings are **auto-generated** when you run `wails dev` or `wails build`. The `frontend/wailsjs/` directory contains generated code - **DO NOT EDIT** these files.

**When Adding New Go Methods:**

1. Add the method to `app.go` (methods on the `App` struct are automatically exposed)
2. Run `wails dev` to generate TypeScript bindings
3. Import and use the method in React components

**Handling New Methods During Development:**

If you need to use a new method before running `wails dev`, declare it temporarily to avoid TypeScript errors:

```typescript
// These functions will be generated by Wails when the app runs
// Declare them here to avoid TypeScript errors during development
declare const NewMethodName: (param: string) => Promise<ReturnType>;

// Use the declared function
const result = await NewMethodName('value');
```

After running `wails dev`, remove the `declare` statement and import normally:

```typescript
import { NewMethodName } from '../wailsjs/go/main/App';
```

### Calling Go Methods from React

```typescript
import { MethodName } from '../wailsjs/go/main/App';

// Async method call
const result = await MethodName(param1, param2);
```

**Available Methods** (from `wailsjs/go/main/App.d.ts`):

**Connection Management:**
- `ConnectWithADC(projectID: string)` - Connect using Application Default Credentials
- `ConnectWithServiceAccount(projectID: string, keyPath: string)` - Connect using service account JSON
- `GetConnectionStatus()` - Get current connection status
- `Disconnect()` - Disconnect from current project
- `SwitchProfile(profileId: string)` - Switch to a different connection profile

**Profiles:**
- `GetProfiles()` - Get all connection profiles
- `SaveProfile(profile: ConnectionProfile)` - Save a connection profile
- `DeleteProfile(profileId: string)` - Delete a connection profile

**Topics:**
- `ListTopics()` - List all topics in the project
- `GetTopicMetadata(topicID: string)` - Get topic metadata
- `CreateTopic(topicID: string, messageRetentionDuration: string)` - Create a new topic
- `DeleteTopic(topicID: string)` - Delete a topic

**Subscriptions:**
- `ListSubscriptions()` - List all subscriptions in the project
- `GetSubscriptionMetadata(subID: string)` - Get subscription metadata
- `CreateSubscription(topicID: string, subID: string, ttlSeconds: number)` - Create a subscription
- `UpdateSubscription(subID: string, params: SubscriptionUpdateParams)` - Update subscription settings
- `DeleteSubscription(subID: string)` - Delete a subscription

**Publishing:**
- `PublishMessage(topicID: string, payload: string, attributes: Record<string, string>)` - Publish a message

**Monitoring:**
- `StartMonitor(subID: string)` - Start monitoring a subscription
- `StopMonitor(subID: string)` - Stop monitoring a subscription
- `StartTopicMonitor(topicID: string)` - Start monitoring a topic (creates temp subscription)
- `StopTopicMonitor(topicID: string)` - Stop topic monitoring
- `GetBufferedMessages(subID: string)` - Get buffered messages for a subscription
- `ClearMessageBuffer(subID: string)` - Clear message buffer
- `GetAutoAck()` - Get auto-acknowledge setting
- `SetAutoAck(enabled: boolean)` - Set auto-acknowledge setting

**Templates:**
- `GetTemplates(topicID: string)` - Get message templates (optionally filtered by topic)
- `SaveTemplate(template: MessageTemplate)` - Save a message template
- `UpdateTemplate(templateID: string, template: MessageTemplate)` - Update a template
- `DeleteTemplate(templateID: string)` - Delete a template

**Configuration:**
- `GetConfigFileContent()` - Get raw config file content
- `SaveConfigFileContent(content: string)` - Save config file content

### Listening to Go Events

```typescript
import { EventsOn } from '../wailsjs/runtime/runtime';

useEffect(() => {
  const unsubscribe = EventsOn('event:name', (data) => {
    // Handle event
  });

  return () => unsubscribe();
}, []);
```

**Common Events:**
- `message:received` - New message from subscription
- `connection:status` - Connection status updates
- `monitor:error` - Monitoring errors

### Error Handling

Always wrap Wails calls in try-catch:

```typescript
try {
  const result = await SomeMethod();
  setError('');
} catch (e: any) {
  setError(e.toString());
}
```

## Type Safety

### Type Definitions

All types are defined in `frontend/src/types/index.ts`:

```typescript
export interface Topic {
  name: string;
  displayName: string;
  messageRetention?: string;
}

export interface Subscription {
  name: string;
  displayName: string;
  topic: string;
  // ...
}
```

**Always:**
- Import types from `types/index.ts`
- Use TypeScript interfaces for props
- Type Wails method return values (use `as` if needed for auto-generated types)

## Layout Structure

The app uses a consistent layout pattern:

```tsx
<Layout sidebar={<Sidebar ... />}>
  {/* Main content */}
</Layout>
```

**Layout Component:**
- Fixed sidebar (320px width, `w-80`)
- Flexible main content area
- Use semantic CSS variables for backgrounds (`var(--color-bg-primary)`, `var(--color-bg-secondary)`)

## State Management

**Current Approach:** React `useState` and `useEffect` (no global state library)

**Patterns:**
- Lift state up to `App.tsx` for shared state (connection status, resources)
- Use local state for component-specific UI state
- Pass callbacks down for actions

**Example:**
```tsx
// In App.tsx
const [topics, setTopics] = useState<Topic[]>([]);
const handleSelectTopic = (topic: Topic) => {
  setSelectedResource({ type: 'topic', id: topic.name });
};

// Pass to child
<TopicDetails topic={topic} />
```

### Async State Management & Connection Switching

**CRITICAL: Always follow these patterns when switching connections or profiles:**

1. **Clear State Immediately**: Always clear dependent state (resources, selections) at the START of any connection switch operation, before any async operations begin.

2. **Proper Async Sequencing**: Always `await` all async operations in sequence. Never call async functions without awaiting them, especially when loading resources after connection changes.

3. **Connection Verification**: After switching connections, verify the connection status and project ID match expectations before loading resources.

4. **Defensive State Updates**: Only update state with new data if the connection is still valid. Check connection status before setting resources.

**Example - Profile Switching Pattern:**
```tsx
const handleProfileSwitch = async () => {
  // 1. Clear state IMMEDIATELY (before any async operations)
  setTopics([]);
  setSubscriptions([]);
  setSelectedResource(null);
  setError('');
  setLoadingResources(true);

  try {
    // 2. Wait for backend operation to complete
    await SwitchProfile(profileId);

    // 3. Get new connection status
    const newStatus = await GetConnectionStatus();
    setStatus(newStatus);

    // 4. Verify connection before loading resources
    if (newStatus.isConnected) {
      // Small delay to ensure backend connection is fully established
      await new Promise(resolve => setTimeout(resolve, 300));

      // 5. Double-check connection still matches
      const verifyStatus = await GetConnectionStatus();
      if (verifyStatus.isConnected && verifyStatus.projectId === newStatus.projectId) {
        // 6. Only then load resources
        await loadResources(); // MUST be awaited
      }
    }
  } catch (e: any) {
    // 7. Clear resources on error to prevent stale data
    setTopics([]);
    setSubscriptions([]);
    setError('Failed to reload resources: ' + e.toString());
  } finally {
    setLoadingResources(false);
  }
};
```

**Example - Resource Loading Pattern:**
```tsx
const loadResources = async () => {
  setLoadingResources(true);
  setError('');

  try {
    // Clear resources first to prevent showing stale data
    setTopics([]);
    setSubscriptions([]);

    const [topicsData, subsData] = await Promise.all([
      ListTopics(),
      ListSubscriptions()
    ]);

    // Verify connection is still valid before setting resources
    const currentStatus = await GetConnectionStatus();
    if (currentStatus.isConnected) {
      setTopics(topicsData as any || []);
      setSubscriptions(subsData as any || []);
    }
  } catch (e: any) {
    setError('Failed to load resources: ' + e.toString());
    // Clear resources on error
    setTopics([]);
    setSubscriptions([]);
  } finally {
    setLoadingResources(false);
  }
};
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Not awaiting async operations
const loadStatus = async () => {
  const s = await GetConnectionStatus();
  setStatus(s);
  if (s.isConnected) {
    loadResources(); // ❌ Not awaited - creates race condition!
  }
};

// ❌ WRONG: Not clearing state before async operations
const handleProfileSwitch = async () => {
  await SwitchProfile(profileId);
  await loadStatus(); // ❌ Old resources still in state!
};

// ❌ WRONG: Not verifying connection before loading
const handleProfileSwitch = async () => {
  setTopics([]); // Good
  await SwitchProfile(profileId);
  await loadResources(); // ❌ May load from wrong connection if switch not complete
};

// ✅ CORRECT: Clear, verify, then load
const handleProfileSwitch = async () => {
  setTopics([]); // Clear immediately
  setSubscriptions([]);
  await SwitchProfile(profileId); // Wait for switch
  const status = await GetConnectionStatus(); // Verify
  if (status.isConnected) {
    await loadResources(); // Load only if verified
  }
};
```

**Key Rules:**
- **Always clear dependent state first** when starting any connection/context switch
- **Always await async operations** - never fire-and-forget async calls that update state
- **Always verify connection** before loading resources after a switch
- **Always clear state on errors** to prevent displaying stale data
- **Use loading states** to prevent UI updates during transitions

## User Action Patterns

### Manual vs Automatic Actions

**CRITICAL**: Always prefer manual user actions over automatic actions for operations that:
- Consume resources (network, CPU, memory)
- Create or modify resources
- Start background processes
- May fail and need user awareness

**Pattern: Manual Action with Button**
```tsx
// ✅ CORRECT: User clicks button to start monitoring
const [isMonitoring, setIsMonitoring] = useState(false);
const [error, setError] = useState('');

const handleStartMonitoring = async () => {
  setError('');
  try {
    await StartMonitoring();
    setIsMonitoring(true);
  } catch (err) {
    setError('Failed to start monitoring: ' + err.toString());
  }
};

return (
  <div>
    {!isMonitoring ? (
      <button onClick={handleStartMonitoring}>Start Monitoring</button>
    ) : (
      <span>Monitoring...</span>
    )}
    {error && <div className="error">{error}</div>}
  </div>
);
```

**Anti-Pattern: Automatic Action**
```tsx
// ❌ WRONG: Automatically starts monitoring when component mounts
useEffect(() => {
  StartMonitoring(); // Starts without user action!
}, [topic]);
```

**When Automatic Actions Are Acceptable:**
- Loading data for display (e.g., loading topic metadata)
- Setting up event listeners
- Initializing UI state
- Loading saved preferences

**When Manual Actions Are Required:**
- Starting monitoring/streaming
- Publishing messages
- Creating/deleting resources
- Connecting to services
- Any operation that may fail and needs user awareness

## Common UI Patterns

### Empty States

Use the `EmptyState` component for empty/initial states:

```tsx
<EmptyState
  icon={<svg>...</svg>}
  title="No Resources"
  description="Connect to a project to see topics and subscriptions."
  action={{
    label: 'Connect',
    onClick: () => handleConnect()
  }}
/>
```

### Loading States

```tsx
{loading ? (
  <div className="flex items-center justify-center p-8">
    <div style={{ color: 'var(--color-text-muted)' }}>Loading...</div>
  </div>
) : (
  // Content
)}
```

### Error Display

**CRITICAL RULE**: All user-facing errors MUST be displayed in the UI. Never rely solely on `console.error` for errors that affect user actions.

**Basic Error Display:**
```tsx
{error && (
  <div
    style={{
      backgroundColor: 'var(--color-error-bg)',
      borderColor: 'var(--color-error-border)',
      color: 'var(--color-error)',
    }}
    className="border rounded-md p-3 mb-4"
  >
    {error}
  </div>
)}
```

**Error Banner Pattern (for prominent errors):**
```tsx
{error && (
  <div
    style={{
      backgroundColor: 'var(--color-error-bg)',
      borderBottomColor: 'color-mix(in srgb, var(--color-error-border) 50%, transparent)',
    }}
    className="p-4 border-b"
  >
    <div className="flex items-start gap-3">
      <svg
        style={{ color: 'var(--color-error)' }}
        className="w-5 h-5 shrink-0 mt-0.5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <div className="flex-1">
        <h4
          style={{ color: 'var(--color-error)' }}
          className="text-sm font-semibold mb-1"
        >
          Error Title
        </h4>
        <p
          style={{ color: 'var(--color-error)' }}
          className="text-sm opacity-90"
        >
          {error}
        </p>
      </div>
    </div>
  </div>
)}
```

**Error State Management Pattern:**
```tsx
const [error, setError] = useState<string>('');

const handleAction = async () => {
  setError(''); // Clear previous errors
  try {
    await someAsyncOperation();
    setError(''); // Clear on success
  } catch (err) {
    // Convert to user-friendly message
    const errorMessage = err instanceof Error ? err.message : String(err);
    let friendlyError = errorMessage;

    // Add context for common error types
    if (errorMessage.includes('Permission denied')) {
      friendlyError = 'Permission denied: You need the "pubsub.subscriptions.create" permission. Please contact your administrator.';
    } else if (errorMessage.includes('NotFound')) {
      friendlyError = 'Resource not found: The resource may not exist or you may not have access to it.';
    }

    setError(friendlyError);
  }
};
```

**Error Handling in Event Listeners:**
```tsx
// When listening to Wails events that might fail
useEffect(() => {
  const unsubscribeError = EventsOn('monitor:error', (data: { error: string }) => {
    setError(data.error); // Display in UI
  });

  return () => unsubscribeError();
}, []);
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Only logging to console
try {
  await someOperation();
} catch (err) {
  console.error('Failed:', err); // User never sees this!
}

// ❌ WRONG: Not converting technical errors
catch (err) {
  setError(err.toString()); // Shows raw API error
}

// ✅ CORRECT: Display in UI with user-friendly message
try {
  await someOperation();
} catch (err) {
  const friendlyError = convertToUserFriendlyMessage(err);
  setError(friendlyError);
}
```

### Tabs (Radix UI)

The codebase uses Radix UI Tabs in `SubscriptionDetails.tsx`:

```tsx
import * as Tabs from '@radix-ui/react-tabs';

// Use CSS for active state styling
<style>{`
  [data-state="active"] {
    color: var(--color-text-primary) !important;
    border-bottom-color: var(--color-accent-primary) !important;
  }
`}</style>

<Tabs.Root value={activeTab} onValueChange={setActiveTab} className="flex flex-col flex-1">
  <Tabs.List
    style={{ borderBottomColor: 'var(--color-border-primary)' }}
    className="flex gap-2 border-b"
  >
    <Tabs.Trigger
      value="metadata"
      style={{
        color: 'var(--color-text-muted)',
        borderBottomWidth: '2px',
        borderBottomStyle: 'solid',
        borderBottomColor: 'transparent',
      }}
      className="px-4 py-2 text-sm font-medium transition-colors hover:opacity-80"
    >
      Metadata
    </Tabs.Trigger>
    <Tabs.Trigger value="monitor" style={{ ... }}>
      Monitor
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="metadata" className="flex-1 overflow-auto">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Best Practices

1. **Accessibility**
   - Use semantic HTML
   - Add ARIA labels where needed
   - Ensure keyboard navigation works
   - Radix UI components handle accessibility automatically

2. **Performance**
   - Use `useMemo` for expensive computations
   - Use `useCallback` for stable function references
   - Avoid unnecessary re-renders

3. **Code Organization**
   - One component per file
   - Keep components focused and small
   - Extract reusable logic into custom hooks

4. **Styling**
   - **PRIORITIZE semantic CSS variables** (`var(--color-*)`) via inline styles or custom CSS classes
   - Use Tailwind utilities only as fallback when semantic styling isn't practical
   - Use consistent spacing scale (Tailwind spacing utilities are fine)
   - All colors must use theme variables for theme compatibility

5. **Error Handling**
   - **CRITICAL**: ALL user-facing errors MUST be displayed in the UI, not just logged to console
   - Always handle async errors with try-catch
   - Display user-friendly error messages with actionable guidance
   - Clear errors on new actions or when operations succeed
   - Use error state management (see Error State Management section below)
   - Convert technical errors to user-friendly messages (e.g., permission errors should explain what permission is needed)
   - Never use `console.error` as the only error handling - always show errors to users

6. **Type Safety**
   - Type all props with interfaces
   - Use TypeScript strict mode
   - Avoid `any` when possible (use `as` for Wails types if needed)

## Development Workflow

### Running the Dev Server

```bash
# From project root
wails dev

# Or standalone frontend (for UI-only development)
cd frontend
npm run dev
```

### Hot Reload

- Wails dev mode supports hot reload for both Go and React
- Frontend changes auto-reload in the desktop window
- Go changes require app restart

### Debugging

- Use browser DevTools (available in Wails dev mode)
- Console logs appear in terminal and DevTools
- React DevTools extension works in dev mode

## Common Gotchas

1. **Wails Bindings**: Never edit files in `wailsjs/` - they're auto-generated
2. **Async Operations**: Always handle loading and error states
3. **Event Cleanup**: Unsubscribe from Wails events in `useEffect` cleanup
4. **Type Assertions**: Wails return types may need `as` assertions for TypeScript
5. **Dark Theme**: All components should work with dark theme (slate colors)
6. **Async State Race Conditions**:
   - **ALWAYS await async operations** that update state
   - **ALWAYS clear dependent state** before starting connection/profile switches
   - **ALWAYS verify connection** before loading resources after a switch
   - Never call async functions without `await` when they update state
7. **Connection Switching**: When switching profiles or connections:
   - Clear resources immediately (topics, subscriptions, selections)
   - Wait for backend switch to complete
   - Verify new connection status
   - Only then load new resources
   - Clear resources on any error
8. **useEffect Dependencies**: Avoid including frequently changing state (like `selectedResource`) in dependency arrays that trigger expensive operations:
   - Use `useRef` to track values needed in event listeners without causing re-renders
   - Split initialization effects from event listener effects
   - Only include dependencies that should trigger the effect
9. **Wails Type Conversion**: When passing complex objects to Wails methods:
   - Use `main.TypeName.createFrom(plainObject)` to convert plain objects to Wails-generated class instances
   - Wails-generated types have `convertValues` method - plain interfaces don't
   - Import Wails models: `import { main } from "../wailsjs/go/models"`

   **Example:**
   ```tsx
   import { main } from "../wailsjs/go/models";
   import { UpdateSubscription } from "../wailsjs/go/main/App";

   // Plain TypeScript interface
   const params = {
     ackDeadline: 30,
     retentionDuration: "7d",
     filter: "attributes.eventType = 'user.signup'"
   };

   // Convert to Wails-generated class instance
   const wailsParams = main.SubscriptionUpdateParams.createFrom(params);

   // Now can be passed to Wails method
   await UpdateSubscription(subID, wailsParams);
   ```

## CRUD Dialog Patterns

### Create/Edit Dialog Structure

```tsx
interface ResourceDialogProps {
  open: boolean;
  mode: 'create' | 'edit';
  resource?: Resource; // For edit mode
  onClose: () => void;
  onCreate?: (params: CreateParams) => Promise<void>;
  onUpdate?: (id: string, params: UpdateParams) => Promise<void>;
  error?: string;
}

export default function ResourceDialog({
  open,
  mode,
  resource,
  onClose,
  onCreate,
  onUpdate,
  error: externalError,
}: ResourceDialogProps) {
  const [formData, setFormData] = useState({});
  const [error, setError] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  // Populate form when editing
  useEffect(() => {
    if (mode === 'edit' && resource) {
      setFormData({ /* populate from resource */ });
    } else {
      setFormData({ /* reset for create */ });
    }
    setError('');
  }, [mode, resource, open]);

  const handleSave = async () => {
    setError('');
    // Validate
    if (!isValid()) {
      setError('Validation error');
      return;
    }

    setIsSaving(true);
    try {
      if (mode === 'create' && onCreate) {
        await onCreate(formData);
      } else if (mode === 'edit' && onUpdate && resource) {
        await onUpdate(resource.id, formData);
      }
      onClose();
    } catch (e: any) {
      setError(e.toString());
    } finally {
      setIsSaving(false);
    }
  };

  if (!open) return null;

  return (
    <div
      style={{
        backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 50%, transparent)',
      }}
      className="fixed inset-0 flex items-center justify-center z-50"
    >
      <div
        style={{
          backgroundColor: 'var(--color-bg-secondary)',
          borderColor: 'var(--color-border-primary)',
          color: 'var(--color-text-primary)',
        }}
        className="border rounded-lg p-6 max-w-md w-full mx-4"
      >
        <h3 className="text-lg font-semibold mb-4">
          {mode === 'create' ? 'Create Resource' : 'Edit Resource'}
        </h3>
        {/* Form fields */}
        {(error || externalError) && (
          <div
            style={{
              backgroundColor: 'var(--color-error-bg)',
              borderColor: 'var(--color-error-border)',
              color: 'var(--color-error)',
            }}
            className="p-3 border rounded text-sm"
          >
            {error || externalError}
          </div>
        )}
        <div className="flex gap-3 justify-end mt-4">
          <button onClick={onClose} disabled={isSaving}>Cancel</button>
          <button onClick={handleSave} disabled={isSaving}>
            {isSaving ? 'Saving...' : mode === 'create' ? 'Create' : 'Save'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

### Delete Confirmation Dialog Pattern

```tsx
interface DeleteConfirmDialogProps {
  open: boolean;
  resourceType: 'topic' | 'subscription';
  resourceName: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export default function DeleteConfirmDialog({
  open,
  resourceType,
  resourceName,
  onConfirm,
  onCancel,
}: DeleteConfirmDialogProps) {
  if (!open) return null;

  const displayName = resourceName.split('/').pop() || resourceName;

  return (
    <div
      style={{
        backgroundColor: 'color-mix(in srgb, var(--color-bg-primary) 50%, transparent)',
      }}
      className="fixed inset-0 flex items-center justify-center z-50"
    >
      <div
        style={{
          backgroundColor: 'var(--color-bg-secondary)',
          borderColor: 'var(--color-border-primary)',
          color: 'var(--color-text-primary)',
        }}
        className="border rounded-lg p-6 max-w-md w-full mx-4"
      >
        <h3
          style={{ color: 'var(--color-error)' }}
          className="text-lg font-semibold mb-4"
        >
          Delete {resourceType === 'topic' ? 'Topic' : 'Subscription'}
        </h3>
        <p
          style={{ color: 'var(--color-text-secondary)' }}
          className="mb-2"
        >
          Are you sure you want to delete this {resourceType}?
        </p>
        <code
          style={{
            backgroundColor: 'var(--color-bg-code)',
            color: 'var(--color-text-primary)',
          }}
          className="block rounded p-3 text-sm mb-3 break-all"
        >
          {displayName}
        </code>
        <p
          style={{ color: 'var(--color-error)' }}
          className="text-sm mb-4"
        >
          This action cannot be undone.
        </p>
        <div className="flex gap-3 justify-end">
          <button onClick={onCancel}>Cancel</button>
          <button
            onClick={onConfirm}
            style={{
              backgroundColor: 'var(--color-error)',
              color: 'white',
            }}
            className="hover:opacity-90 transition-opacity"
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--color-error-hover)'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'var(--color-error)'}
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}
```

### Event-Driven UI Updates

Use Wails events to refresh UI after CRUD operations:

```tsx
useEffect(() => {
  // Set up event listeners once on mount
  const unsubscribeTopicCreated = EventsOn('topic:created', () => {
    loadResources(); // Refresh list
  });

  const unsubscribeTopicDeleted = EventsOn('topic:deleted', () => {
    loadResources();
    // Clear selection if deleted resource was selected
    if (selectedResourceRef.current?.type === 'topic') {
      setSelectedResource(null);
    }
  });

  return () => {
    unsubscribeTopicCreated();
    unsubscribeTopicDeleted();
  };
}, []); // Empty dependency array - only set up once

// Use ref to track selectedResource without causing re-renders
const selectedResourceRef = useRef(selectedResource);
useEffect(() => {
  selectedResourceRef.current = selectedResource;
}, [selectedResource]);
```

**Key Pattern:**
- Set up event listeners once in `useEffect` with empty dependency array
- Use `useRef` to track state values needed in event callbacks
- Update ref in separate `useEffect` when state changes
- This prevents unnecessary re-initialization of event listeners

## Resources

- [Tailwind CSS v4 Docs](https://tailwindcss.com/docs)
- [Radix UI Docs](https://www.radix-ui.com/)
- [Wails v2 Docs](https://wails.io/docs/v2/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
