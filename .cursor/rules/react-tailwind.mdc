---
description: UI Development Guide for Pub/Sub GUI
alwaysApply: false
---
# UI Development Guide for Pub/Sub GUI

This guide covers UI development patterns, conventions, and best practices for the Pub/Sub GUI desktop application.

## Tech Stack

- **Framework**: React 18 with TypeScript
- **Styling**: Tailwind CSS v4 (using `@tailwindcss/postcss`)
- **UI Components**: Radix UI (accessible, unstyled primitives)
- **Build Tool**: Vite 3
- **Desktop Framework**: Wails v2 (Go backend + React frontend)

## Project Structure

```
frontend/src/
├── components/          # React components
│   ├── Layout.tsx      # Main layout wrapper (sidebar + main)
│   ├── Sidebar.tsx     # Resource navigation sidebar
│   ├── TopicDetails.tsx
│   ├── SubscriptionDetails.tsx
│   └── ...
├── types/              # TypeScript type definitions
│   └── index.ts
├── wailsjs/           # Auto-generated Wails bindings (DO NOT EDIT)
│   └── go/main/App.js
├── App.tsx            # Root component
├── main.tsx           # React entry point
└── style.css          # Global styles + Tailwind imports
```

## Component Patterns

### Component Structure

```typescript
import { useState, useEffect } from 'react';
import type { Topic } from '../types';
import { SomeWailsMethod } from '../wailsjs/go/main/App';

interface ComponentProps {
  topic: Topic;
  onAction?: () => void;
}

export default function Component({ topic, onAction }: ComponentProps) {
  const [state, setState] = useState<string>('');

  useEffect(() => {
    // Side effects
  }, [topic]);

  return (
    <div className="...">
      {/* Component JSX */}
    </div>
  );
}
```

### Naming Conventions

- **Components**: PascalCase, descriptive names (e.g., `TopicDetails`, `ConnectionDialog`)
- **Files**: Match component name (e.g., `TopicDetails.tsx`)
- **Props interfaces**: `ComponentNameProps` (e.g., `TopicDetailsProps`)
- **Types**: PascalCase, exported from `types/index.ts`

## Styling Guidelines

### Tailwind CSS v4 Usage

This project uses **Tailwind CSS v4** with the new `@import "tailwindcss"` syntax.

**Key Principles:**
1. **Use Tailwind utility classes** for all styling (prefer over custom CSS)
2. **Dark theme by default**: The app uses a dark color scheme (slate-800/900 backgrounds)
3. **Consistent spacing**: Use Tailwind's spacing scale (p-4, m-2, gap-3, etc.)
4. **Responsive design**: Not required for desktop app, but maintain consistent sizing

### Color Palette

The app uses a dark theme with slate colors:

```typescript
// Backgrounds
bg-slate-900    // Main app background
bg-slate-800    // Sidebar, cards, elevated surfaces
bg-slate-700    // Inputs, buttons, hover states
bg-slate-600    // Active states, borders

// Text
text-slate-100  // Primary text
text-slate-200  // Secondary text
text-slate-400  // Muted text, placeholders
text-slate-500  // Disabled text

// Accents
text-blue-500   // Links, focus rings
bg-blue-500     // Primary actions
ring-blue-500   // Focus indicators
```

### Common Patterns

**Buttons:**
```tsx
// Primary button
<button className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors">
  Submit
</button>

// Secondary button
<button className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-md transition-colors">
  Cancel
</button>

// Text button
<button className="text-slate-400 hover:text-slate-200 transition-colors">
  Disconnect
</button>
```

**Input Fields:**
```tsx
<input
  type="text"
  value={value}
  onChange={(e) => setValue(e.target.value)}
  className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-md text-sm text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
  placeholder="Enter text..."
/>
```

**Cards/Panels:**
```tsx
<div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
  {/* Card content */}
</div>
```

**Loading States:**
```tsx
<button disabled={loading} className="... disabled:opacity-50 disabled:cursor-not-allowed">
  {loading ? 'Loading...' : 'Submit'}
</button>
```

## Radix UI Integration

Radix UI provides accessible, unstyled primitives. Always style them with Tailwind classes.

**Radix Components Available:**
- `@radix-ui/react-tabs` - ✅ **Used** in `SubscriptionDetails.tsx` for tabbed interfaces
- `@radix-ui/react-dialog` - Available but not currently used (codebase uses custom modals)
- `@radix-ui/react-dropdown-menu` - Available for dropdown menus
- `@radix-ui/react-select` - Available for select dropdowns
- `@radix-ui/react-label` - Available for form labels
- `@radix-ui/react-separator` - Available for visual separators

**Note:** The codebase currently uses custom div-based modals instead of Radix Dialog. Radix Dialog is available if you want to use it for better accessibility features.

**Example - Custom Modal (Current Pattern):**
```tsx
interface DialogProps {
  open: boolean;
  onClose: () => void;
}

export default function CustomDialog({ open, onClose }: DialogProps) {
  if (!open) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-slate-800 border border-slate-700 rounded-lg p-6 max-w-md w-full mx-4">
        <h3 className="text-lg font-semibold mb-4">Title</h3>
        {/* Content */}
        <div className="flex gap-3 justify-end mt-4">
          <button onClick={onClose}>Cancel</button>
          <button onClick={handleSave}>Save</button>
        </div>
      </div>
    </div>
  );
}
```

**Example - Radix Tabs (Used in Codebase):**
```tsx
import * as Tabs from '@radix-ui/react-tabs';

<Tabs.Root value={activeTab} onValueChange={setActiveTab}>
  <Tabs.List className="flex border-b border-slate-700">
    <Tabs.Trigger value="tab1" className="px-4 py-2 data-[state=active]:border-b-2 data-[state=active]:border-blue-500">
      Tab 1
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="tab1">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Wails Integration

### Wails Binding Generation

**Important:** Wails TypeScript bindings are **auto-generated** when you run `wails dev` or `wails build`. The `frontend/wailsjs/` directory contains generated code - **DO NOT EDIT** these files.

**When Adding New Go Methods:**

1. Add the method to `app.go` (methods on the `App` struct are automatically exposed)
2. Run `wails dev` to generate TypeScript bindings
3. Import and use the method in React components

**Handling New Methods During Development:**

If you need to use a new method before running `wails dev`, declare it temporarily to avoid TypeScript errors:

```typescript
// These functions will be generated by Wails when the app runs
// Declare them here to avoid TypeScript errors during development
declare const NewMethodName: (param: string) => Promise<ReturnType>;

// Use the declared function
const result = await NewMethodName('value');
```

After running `wails dev`, remove the `declare` statement and import normally:

```typescript
import { NewMethodName } from '../wailsjs/go/main/App';
```

### Calling Go Methods from React

```typescript
import { MethodName } from '../wailsjs/go/main/App';

// Async method call
const result = await MethodName(param1, param2);
```

**Available Methods** (from `wailsjs/go/main/App.d.ts`):

**Connection Management:**
- `ConnectWithADC(projectID: string)` - Connect using Application Default Credentials
- `ConnectWithServiceAccount(projectID: string, keyPath: string)` - Connect using service account JSON
- `GetConnectionStatus()` - Get current connection status
- `Disconnect()` - Disconnect from current project
- `SwitchProfile(profileId: string)` - Switch to a different connection profile

**Profiles:**
- `GetProfiles()` - Get all connection profiles
- `SaveProfile(profile: ConnectionProfile)` - Save a connection profile
- `DeleteProfile(profileId: string)` - Delete a connection profile

**Topics:**
- `ListTopics()` - List all topics in the project
- `GetTopicMetadata(topicID: string)` - Get topic metadata
- `CreateTopic(topicID: string, messageRetentionDuration: string)` - Create a new topic
- `DeleteTopic(topicID: string)` - Delete a topic

**Subscriptions:**
- `ListSubscriptions()` - List all subscriptions in the project
- `GetSubscriptionMetadata(subID: string)` - Get subscription metadata
- `CreateSubscription(topicID: string, subID: string, ttlSeconds: number)` - Create a subscription
- `UpdateSubscription(subID: string, params: SubscriptionUpdateParams)` - Update subscription settings
- `DeleteSubscription(subID: string)` - Delete a subscription

**Publishing:**
- `PublishMessage(topicID: string, payload: string, attributes: Record<string, string>)` - Publish a message

**Monitoring:**
- `StartMonitor(subID: string)` - Start monitoring a subscription
- `StopMonitor(subID: string)` - Stop monitoring a subscription
- `StartTopicMonitor(topicID: string)` - Start monitoring a topic (creates temp subscription)
- `StopTopicMonitor(topicID: string)` - Stop topic monitoring
- `GetBufferedMessages(subID: string)` - Get buffered messages for a subscription
- `ClearMessageBuffer(subID: string)` - Clear message buffer
- `GetAutoAck()` - Get auto-acknowledge setting
- `SetAutoAck(enabled: boolean)` - Set auto-acknowledge setting

**Templates:**
- `GetTemplates(topicID: string)` - Get message templates (optionally filtered by topic)
- `SaveTemplate(template: MessageTemplate)` - Save a message template
- `UpdateTemplate(templateID: string, template: MessageTemplate)` - Update a template
- `DeleteTemplate(templateID: string)` - Delete a template

**Configuration:**
- `GetConfigFileContent()` - Get raw config file content
- `SaveConfigFileContent(content: string)` - Save config file content

### Listening to Go Events

```typescript
import { EventsOn } from '../wailsjs/runtime/runtime';

useEffect(() => {
  const unsubscribe = EventsOn('event:name', (data) => {
    // Handle event
  });

  return () => unsubscribe();
}, []);
```

**Common Events:**
- `message:received` - New message from subscription
- `connection:status` - Connection status updates
- `monitor:error` - Monitoring errors

### Error Handling

Always wrap Wails calls in try-catch:

```typescript
try {
  const result = await SomeMethod();
  setError('');
} catch (e: any) {
  setError(e.toString());
}
```

## Type Safety

### Type Definitions

All types are defined in `frontend/src/types/index.ts`:

```typescript
export interface Topic {
  name: string;
  displayName: string;
  messageRetention?: string;
}

export interface Subscription {
  name: string;
  displayName: string;
  topic: string;
  // ...
}
```

**Always:**
- Import types from `types/index.ts`
- Use TypeScript interfaces for props
- Type Wails method return values (use `as` if needed for auto-generated types)

## Layout Structure

The app uses a consistent layout pattern:

```tsx
<Layout sidebar={<Sidebar ... />}>
  {/* Main content */}
</Layout>
```

**Layout Component:**
- Fixed sidebar (320px width, `w-80`)
- Flexible main content area
- Dark theme (`bg-slate-900`, `bg-slate-800`)

## State Management

**Current Approach:** React `useState` and `useEffect` (no global state library)

**Patterns:**
- Lift state up to `App.tsx` for shared state (connection status, resources)
- Use local state for component-specific UI state
- Pass callbacks down for actions

**Example:**
```tsx
// In App.tsx
const [topics, setTopics] = useState<Topic[]>([]);
const handleSelectTopic = (topic: Topic) => {
  setSelectedResource({ type: 'topic', id: topic.name });
};

// Pass to child
<TopicDetails topic={topic} />
```

### Async State Management & Connection Switching

**CRITICAL: Always follow these patterns when switching connections or profiles:**

1. **Clear State Immediately**: Always clear dependent state (resources, selections) at the START of any connection switch operation, before any async operations begin.

2. **Proper Async Sequencing**: Always `await` all async operations in sequence. Never call async functions without awaiting them, especially when loading resources after connection changes.

3. **Connection Verification**: After switching connections, verify the connection status and project ID match expectations before loading resources.

4. **Defensive State Updates**: Only update state with new data if the connection is still valid. Check connection status before setting resources.

**Example - Profile Switching Pattern:**
```tsx
const handleProfileSwitch = async () => {
  // 1. Clear state IMMEDIATELY (before any async operations)
  setTopics([]);
  setSubscriptions([]);
  setSelectedResource(null);
  setError('');
  setLoadingResources(true);

  try {
    // 2. Wait for backend operation to complete
    await SwitchProfile(profileId);

    // 3. Get new connection status
    const newStatus = await GetConnectionStatus();
    setStatus(newStatus);

    // 4. Verify connection before loading resources
    if (newStatus.isConnected) {
      // Small delay to ensure backend connection is fully established
      await new Promise(resolve => setTimeout(resolve, 300));

      // 5. Double-check connection still matches
      const verifyStatus = await GetConnectionStatus();
      if (verifyStatus.isConnected && verifyStatus.projectId === newStatus.projectId) {
        // 6. Only then load resources
        await loadResources(); // MUST be awaited
      }
    }
  } catch (e: any) {
    // 7. Clear resources on error to prevent stale data
    setTopics([]);
    setSubscriptions([]);
    setError('Failed to reload resources: ' + e.toString());
  } finally {
    setLoadingResources(false);
  }
};
```

**Example - Resource Loading Pattern:**
```tsx
const loadResources = async () => {
  setLoadingResources(true);
  setError('');

  try {
    // Clear resources first to prevent showing stale data
    setTopics([]);
    setSubscriptions([]);

    const [topicsData, subsData] = await Promise.all([
      ListTopics(),
      ListSubscriptions()
    ]);

    // Verify connection is still valid before setting resources
    const currentStatus = await GetConnectionStatus();
    if (currentStatus.isConnected) {
      setTopics(topicsData as any || []);
      setSubscriptions(subsData as any || []);
    }
  } catch (e: any) {
    setError('Failed to load resources: ' + e.toString());
    // Clear resources on error
    setTopics([]);
    setSubscriptions([]);
  } finally {
    setLoadingResources(false);
  }
};
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Not awaiting async operations
const loadStatus = async () => {
  const s = await GetConnectionStatus();
  setStatus(s);
  if (s.isConnected) {
    loadResources(); // ❌ Not awaited - creates race condition!
  }
};

// ❌ WRONG: Not clearing state before async operations
const handleProfileSwitch = async () => {
  await SwitchProfile(profileId);
  await loadStatus(); // ❌ Old resources still in state!
};

// ❌ WRONG: Not verifying connection before loading
const handleProfileSwitch = async () => {
  setTopics([]); // Good
  await SwitchProfile(profileId);
  await loadResources(); // ❌ May load from wrong connection if switch not complete
};

// ✅ CORRECT: Clear, verify, then load
const handleProfileSwitch = async () => {
  setTopics([]); // Clear immediately
  setSubscriptions([]);
  await SwitchProfile(profileId); // Wait for switch
  const status = await GetConnectionStatus(); // Verify
  if (status.isConnected) {
    await loadResources(); // Load only if verified
  }
};
```

**Key Rules:**
- **Always clear dependent state first** when starting any connection/context switch
- **Always await async operations** - never fire-and-forget async calls that update state
- **Always verify connection** before loading resources after a switch
- **Always clear state on errors** to prevent displaying stale data
- **Use loading states** to prevent UI updates during transitions

## User Action Patterns

### Manual vs Automatic Actions

**CRITICAL**: Always prefer manual user actions over automatic actions for operations that:
- Consume resources (network, CPU, memory)
- Create or modify resources
- Start background processes
- May fail and need user awareness

**Pattern: Manual Action with Button**
```tsx
// ✅ CORRECT: User clicks button to start monitoring
const [isMonitoring, setIsMonitoring] = useState(false);
const [error, setError] = useState('');

const handleStartMonitoring = async () => {
  setError('');
  try {
    await StartMonitoring();
    setIsMonitoring(true);
  } catch (err) {
    setError('Failed to start monitoring: ' + err.toString());
  }
};

return (
  <div>
    {!isMonitoring ? (
      <button onClick={handleStartMonitoring}>Start Monitoring</button>
    ) : (
      <span>Monitoring...</span>
    )}
    {error && <div className="error">{error}</div>}
  </div>
);
```

**Anti-Pattern: Automatic Action**
```tsx
// ❌ WRONG: Automatically starts monitoring when component mounts
useEffect(() => {
  StartMonitoring(); // Starts without user action!
}, [topic]);
```

**When Automatic Actions Are Acceptable:**
- Loading data for display (e.g., loading topic metadata)
- Setting up event listeners
- Initializing UI state
- Loading saved preferences

**When Manual Actions Are Required:**
- Starting monitoring/streaming
- Publishing messages
- Creating/deleting resources
- Connecting to services
- Any operation that may fail and needs user awareness

## Common UI Patterns

### Empty States

Use the `EmptyState` component for empty/initial states:

```tsx
<EmptyState
  icon={<svg>...</svg>}
  title="No Resources"
  description="Connect to a project to see topics and subscriptions."
  action={{
    label: 'Connect',
    onClick: () => handleConnect()
  }}
/>
```

### Loading States

```tsx
{loading ? (
  <div className="flex items-center justify-center p-8">
    <div className="text-slate-400">Loading...</div>
  </div>
) : (
  // Content
)}
```

### Error Display

**CRITICAL RULE**: All user-facing errors MUST be displayed in the UI. Never rely solely on `console.error` for errors that affect user actions.

**Basic Error Display:**
```tsx
{error && (
  <div className="bg-red-900/20 border border-red-700 text-red-200 rounded-md p-3 mb-4">
    {error}
  </div>
)}
```

**Error Banner Pattern (for prominent errors):**
```tsx
{error && (
  <div className="p-4 bg-red-900/20 border-b border-red-700/50">
    <div className="flex items-start gap-3">
      <svg className="w-5 h-5 text-red-400 shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <div className="flex-1">
        <h4 className="text-sm font-semibold text-red-400 mb-1">Error Title</h4>
        <p className="text-sm text-red-300">{error}</p>
      </div>
    </div>
  </div>
)}
```

**Error State Management Pattern:**
```tsx
const [error, setError] = useState<string>('');

const handleAction = async () => {
  setError(''); // Clear previous errors
  try {
    await someAsyncOperation();
    setError(''); // Clear on success
  } catch (err) {
    // Convert to user-friendly message
    const errorMessage = err instanceof Error ? err.message : String(err);
    let friendlyError = errorMessage;

    // Add context for common error types
    if (errorMessage.includes('Permission denied')) {
      friendlyError = 'Permission denied: You need the "pubsub.subscriptions.create" permission. Please contact your administrator.';
    } else if (errorMessage.includes('NotFound')) {
      friendlyError = 'Resource not found: The resource may not exist or you may not have access to it.';
    }

    setError(friendlyError);
  }
};
```

**Error Handling in Event Listeners:**
```tsx
// When listening to Wails events that might fail
useEffect(() => {
  const unsubscribeError = EventsOn('monitor:error', (data: { error: string }) => {
    setError(data.error); // Display in UI
  });

  return () => unsubscribeError();
}, []);
```

**Anti-Patterns to Avoid:**
```tsx
// ❌ WRONG: Only logging to console
try {
  await someOperation();
} catch (err) {
  console.error('Failed:', err); // User never sees this!
}

// ❌ WRONG: Not converting technical errors
catch (err) {
  setError(err.toString()); // Shows raw API error
}

// ✅ CORRECT: Display in UI with user-friendly message
try {
  await someOperation();
} catch (err) {
  const friendlyError = convertToUserFriendlyMessage(err);
  setError(friendlyError);
}
```

### Tabs (Radix UI)

The codebase uses Radix UI Tabs in `SubscriptionDetails.tsx`:

```tsx
import * as Tabs from '@radix-ui/react-tabs';

<Tabs.Root value={activeTab} onValueChange={setActiveTab} className="flex flex-col flex-1">
  <Tabs.List className="flex gap-2 border-b border-slate-700">
    <Tabs.Trigger
      value="metadata"
      className="px-4 py-2 text-sm font-medium text-slate-400 hover:text-slate-200 data-[state=active]:text-slate-100 data-[state=active]:border-b-2 data-[state=active]:border-green-500 transition-colors"
    >
      Metadata
    </Tabs.Trigger>
    <Tabs.Trigger value="monitor" className="...">
      Monitor
    </Tabs.Trigger>
  </Tabs.List>
  <Tabs.Content value="metadata" className="flex-1 overflow-auto">
    {/* Content */}
  </Tabs.Content>
</Tabs.Root>
```

## Best Practices

1. **Accessibility**
   - Use semantic HTML
   - Add ARIA labels where needed
   - Ensure keyboard navigation works
   - Radix UI components handle accessibility automatically

2. **Performance**
   - Use `useMemo` for expensive computations
   - Use `useCallback` for stable function references
   - Avoid unnecessary re-renders

3. **Code Organization**
   - One component per file
   - Keep components focused and small
   - Extract reusable logic into custom hooks

4. **Styling**
   - Prefer Tailwind utilities over custom CSS
   - Use consistent spacing scale
   - Maintain dark theme consistency

5. **Error Handling**
   - **CRITICAL**: ALL user-facing errors MUST be displayed in the UI, not just logged to console
   - Always handle async errors with try-catch
   - Display user-friendly error messages with actionable guidance
   - Clear errors on new actions or when operations succeed
   - Use error state management (see Error State Management section below)
   - Convert technical errors to user-friendly messages (e.g., permission errors should explain what permission is needed)
   - Never use `console.error` as the only error handling - always show errors to users

6. **Type Safety**
   - Type all props with interfaces
   - Use TypeScript strict mode
   - Avoid `any` when possible (use `as` for Wails types if needed)

## Development Workflow

### Running the Dev Server

```bash
# From project root
wails dev

# Or standalone frontend (for UI-only development)
cd frontend
npm run dev
```

### Hot Reload

- Wails dev mode supports hot reload for both Go and React
- Frontend changes auto-reload in the desktop window
- Go changes require app restart

### Debugging

- Use browser DevTools (available in Wails dev mode)
- Console logs appear in terminal and DevTools
- React DevTools extension works in dev mode

## Common Gotchas

1. **Wails Bindings**: Never edit files in `wailsjs/` - they're auto-generated
2. **Async Operations**: Always handle loading and error states
3. **Event Cleanup**: Unsubscribe from Wails events in `useEffect` cleanup
4. **Type Assertions**: Wails return types may need `as` assertions for TypeScript
5. **Dark Theme**: All components should work with dark theme (slate colors)
6. **Async State Race Conditions**:
   - **ALWAYS await async operations** that update state
   - **ALWAYS clear dependent state** before starting connection/profile switches
   - **ALWAYS verify connection** before loading resources after a switch
   - Never call async functions without `await` when they update state
7. **Connection Switching**: When switching profiles or connections:
   - Clear resources immediately (topics, subscriptions, selections)
   - Wait for backend switch to complete
   - Verify new connection status
   - Only then load new resources
   - Clear resources on any error
8. **useEffect Dependencies**: Avoid including frequently changing state (like `selectedResource`) in dependency arrays that trigger expensive operations:
   - Use `useRef` to track values needed in event listeners without causing re-renders
   - Split initialization effects from event listener effects
   - Only include dependencies that should trigger the effect
9. **Wails Type Conversion**: When passing complex objects to Wails methods:
   - Use `main.TypeName.createFrom(plainObject)` to convert plain objects to Wails-generated class instances
   - Wails-generated types have `convertValues` method - plain interfaces don't
   - Import Wails models: `import { main } from "../wailsjs/go/models"`

   **Example:**
   ```tsx
   import { main } from "../wailsjs/go/models";
   import { UpdateSubscription } from "../wailsjs/go/main/App";

   // Plain TypeScript interface
   const params = {
     ackDeadline: 30,
     retentionDuration: "7d",
     filter: "attributes.eventType = 'user.signup'"
   };

   // Convert to Wails-generated class instance
   const wailsParams = main.SubscriptionUpdateParams.createFrom(params);

   // Now can be passed to Wails method
   await UpdateSubscription(subID, wailsParams);
   ```

## CRUD Dialog Patterns

### Create/Edit Dialog Structure

```tsx
interface ResourceDialogProps {
  open: boolean;
  mode: 'create' | 'edit';
  resource?: Resource; // For edit mode
  onClose: () => void;
  onCreate?: (params: CreateParams) => Promise<void>;
  onUpdate?: (id: string, params: UpdateParams) => Promise<void>;
  error?: string;
}

export default function ResourceDialog({
  open,
  mode,
  resource,
  onClose,
  onCreate,
  onUpdate,
  error: externalError,
}: ResourceDialogProps) {
  const [formData, setFormData] = useState({});
  const [error, setError] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  // Populate form when editing
  useEffect(() => {
    if (mode === 'edit' && resource) {
      setFormData({ /* populate from resource */ });
    } else {
      setFormData({ /* reset for create */ });
    }
    setError('');
  }, [mode, resource, open]);

  const handleSave = async () => {
    setError('');
    // Validate
    if (!isValid()) {
      setError('Validation error');
      return;
    }

    setIsSaving(true);
    try {
      if (mode === 'create' && onCreate) {
        await onCreate(formData);
      } else if (mode === 'edit' && onUpdate && resource) {
        await onUpdate(resource.id, formData);
      }
      onClose();
    } catch (e: any) {
      setError(e.toString());
    } finally {
      setIsSaving(false);
    }
  };

  if (!open) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-slate-800 border border-slate-700 rounded-lg p-6 max-w-md w-full mx-4">
        <h3 className="text-lg font-semibold mb-4">
          {mode === 'create' ? 'Create Resource' : 'Edit Resource'}
        </h3>
        {/* Form fields */}
        {(error || externalError) && (
          <div className="p-3 bg-red-900/20 border border-red-700 rounded text-red-400 text-sm">
            {error || externalError}
          </div>
        )}
        <div className="flex gap-3 justify-end mt-4">
          <button onClick={onClose} disabled={isSaving}>Cancel</button>
          <button onClick={handleSave} disabled={isSaving}>
            {isSaving ? 'Saving...' : mode === 'create' ? 'Create' : 'Save'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

### Delete Confirmation Dialog Pattern

```tsx
interface DeleteConfirmDialogProps {
  open: boolean;
  resourceType: 'topic' | 'subscription';
  resourceName: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export default function DeleteConfirmDialog({
  open,
  resourceType,
  resourceName,
  onConfirm,
  onCancel,
}: DeleteConfirmDialogProps) {
  if (!open) return null;

  const displayName = resourceName.split('/').pop() || resourceName;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-slate-800 border border-slate-700 rounded-lg p-6 max-w-md w-full mx-4">
        <h3 className="text-lg font-semibold mb-4 text-red-400">
          Delete {resourceType === 'topic' ? 'Topic' : 'Subscription'}
        </h3>
        <p className="text-slate-300 mb-2">
          Are you sure you want to delete this {resourceType}?
        </p>
        <code className="block bg-slate-900 rounded p-3 text-sm mb-3 break-all">
          {displayName}
        </code>
        <p className="text-sm text-red-400 mb-4">
          This action cannot be undone.
        </p>
        <div className="flex gap-3 justify-end">
          <button onClick={onCancel}>Cancel</button>
          <button onClick={onConfirm} className="bg-red-600 hover:bg-red-700">
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}
```

### Event-Driven UI Updates

Use Wails events to refresh UI after CRUD operations:

```tsx
useEffect(() => {
  // Set up event listeners once on mount
  const unsubscribeTopicCreated = EventsOn('topic:created', () => {
    loadResources(); // Refresh list
  });

  const unsubscribeTopicDeleted = EventsOn('topic:deleted', () => {
    loadResources();
    // Clear selection if deleted resource was selected
    if (selectedResourceRef.current?.type === 'topic') {
      setSelectedResource(null);
    }
  });

  return () => {
    unsubscribeTopicCreated();
    unsubscribeTopicDeleted();
  };
}, []); // Empty dependency array - only set up once

// Use ref to track selectedResource without causing re-renders
const selectedResourceRef = useRef(selectedResource);
useEffect(() => {
  selectedResourceRef.current = selectedResource;
}, [selectedResource]);
```

**Key Pattern:**
- Set up event listeners once in `useEffect` with empty dependency array
- Use `useRef` to track state values needed in event callbacks
- Update ref in separate `useEffect` when state changes
- This prevents unnecessary re-initialization of event listeners

## Resources

- [Tailwind CSS v4 Docs](https://tailwindcss.com/docs)
- [Radix UI Docs](https://www.radix-ui.com/)
- [Wails v2 Docs](https://wails.io/docs/v2/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
